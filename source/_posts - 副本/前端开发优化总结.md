title: "前端开发优化总结"
id: 612
date: 2010-08-31 18:38:21
tags: 
categories: 
- CSS
- JavaScript
- 网络技术
---

发现的一篇关于**前端优化**的文章，总结的很全面，要做到面面俱到很难，往往是想优化而没有时间去优化，就像我们公司，一个项目连着一个项目~新员工的培训都省了，还想优化前端啊，不过我真的想有机会和[老大](http://www.qicaisky.com/)好好的整合下公司网站的前端代码~不过要把前端优化的工作放在平时的写代码中去，就不需要刻意的后期优化了。在项目开发中，后台需要搭建好框架，前端更是需要搭建好框架，并且在页面实现中得到实现，只有这样才能事半功倍。

前段时间简单的研究了下前端优化相关的知识，本文算是一个阶段性的总结，或者当做一个优化的参考List。

### 前言

前端是庞大的，包括HTML、CSS、Javascript、Image、Flash等等各种各样的资源。**前端优化**是复杂的，针对方方面面的资源都有不同的方式。那么，前端优化的目的是什么？

1.  从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。
2.  从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。
总之，恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。

前端优化的途径有很多，按粒度大致可以分为两类，第一类是页面级别的优化，例如HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等；第二类则是代码级别的优化，例如Javascript中的DOM操作优化、CSS选择符优化、图片优化以及HTML结构优化等等。另外，本着提高投入产出比的目的，后文提到的各种优化策略大致按照投入产出比从大到小的顺序排列。

### 一、页面级优化

<!--more-->
**1\. 减少HTTP请求数**

这条策略基本上所有前端人都知道，而且也是最重要最有效的。都说要减少**HTTP**请求，那请求多了到底会怎么样呢？首先，每个请求都是有成本的，既包含时间成本也包含资源成本。一个完整的请求都需要经过DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个“漫长”而复杂的过程。时间成本就是用户需要看到或者“感受”到这个资源是必须要等待这个过程结束的，资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。另外，由于浏览器进行并发请求的请求数是有上限的(具体参见[此处](http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/))，因此请求数多了以后，浏览器需要分批进行请求，因此会增加用户的等待时间，会给用户造成站点速度慢这样一个印象，即使可能用户能看到的第一屏的资源都已经请求完了，但是浏览器的进度条会一直存在。

减少HTTP请求数的主要途径包括：

(1). 从设计实现层面简化页面

如果你的页面像百度首页一样简单，那么接下来的规则基本上都用不着了。保持页面简洁、减少资源的使用时最直接的。如果不是这样，你的页面需要华丽的皮肤，则继续阅读下面的内容。

(2). 合理设置HTTP缓存

缓存的力量是强大的，恰当的缓存设置可以大大的减少HTTP请求。以[有啊首页](http://youa.baidu.com/)为例，当浏览器没有缓存的时候访问一共会发出78个请求，共600多K数据（如图1.1），而当第二次访问即浏览器已缓存之后访问则仅有10个请求，共20多K数据（如图1.2）。（这里需要说明的是，如果直接F5刷新页面的话效果是不一样的，这种情况下请求数还是一样，不过被缓存资源的请求服务器是304响应，只有Header没有Body，可以节省带宽）

[caption id="attachment_613" align="aligncenter" width="300" caption="如图1.1"][![如图1.2](http://js8.in/wp-content/uploads/2010/08/image-300x134.png "如图1.2")](http://js8.in/wp-content/uploads/2010/08/image.png)[/caption]

[caption id="attachment_614" align="aligncenter" width="244" caption="如图1.2"][![如图1.2](http://js8.in/wp-content/uploads/2010/08/image-thumb1.png "如图1.2")](http://js8.in/wp-content/uploads/2010/08/image-thumb1.png)[/caption]

怎样才算合理设置？原则很简单，能缓存越多越好，能缓存越久越好。例如，很少变化的图片资源可以直接通过HTTP Header中的Expires设置一个很长的过期头；变化不频繁而又可能会变的资源可以使用Last-Modifed来做请求验证。尽可能的让资源能够在缓存中待得更久。关于HTTP缓存的具体设置和原理此处就不再详述了，有兴趣的可以参考下列文章：

[HTTP1.1协议中关于缓存策略的描述](http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html)

[Fiddler HTTP Performance中关于缓存的介绍](http://msdn.microsoft.com/en-us/library/bb250442(VS.85).aspx)

(3). 资源合并与压缩

如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个。另外，CSS、Javascript、Image都可以用相应的工具进行压缩，压缩后往往能省下不少空间。

(4). CSS Sprites

合并CSS图片，减少请求数的又一个好办法。

(5). Inline Images

使用data: [URL scheme](http://tools.ietf.org/html/rfc2397)的方式将图片嵌入到页面或CSS中，如果不考虑资源管理上的问题的话，不失为一个好办法。如果是嵌入页面的话换来的是增大了页面的体积，而且无法利用浏览器缓存。使用在CSS中的图片则更为理想一些。

(6). Lazy Load Images

这条策略实际上并不一定能减少HTTP请求数，但是却能在某些条件下或者页面刚加载时减少HTTP请求数。对于图片而言，在页面刚加载的时候可以只加载第一屏，当用户继续往后滚屏的时候才加载后续的图片。这样一来，假如用户只对第一屏的内容感兴趣时，那剩余的图片请求就都节省了。有啊首页曾经的做法是在加载的时候把第一屏之后的图片地址缓存在Textarea标签中，待用户往下滚屏的时候才“惰性”加载。

**2\. 将外部脚本置底**

前文有谈到，浏览器是可以并发请求的，这一特点使得其能够更快的加载资源，然而外链脚本在加载时却会阻塞其他资源，例如在脚本加载完成之前，它后面的图片、样式以及其他脚本都处于阻塞状态，直到脚本加载完成后才会开始加载。如果将脚本放在比较靠前的位置，则会影响整个页面的加载速度从而影响用户体验。解决这一问题的方法有很多，在这里有比较[详细的介绍](http://www.stevesouders.com/blog/2009/04/27/loading-scripts-without-blocking/)（[这里是译文和更详细的例子](http://varnow.org/?p=42)），而最简单可依赖的方法就是将脚本尽可能的往后挪，减少对并发下载的影响。

**3\. 异步执行inline脚本**

inline脚本对性能的影响与外部脚本相比，是有过之而无不及。首页，与外部脚本一样，inline脚本在执行的时候一样会阻塞并发请求，除此之外，由于浏览器在页面处理方面是单线程的，当inline脚本在页面渲染之前执行时，页面的渲染工作则会被推迟。简而言之，inline脚本在执行的时候，页面处于空白状态。鉴于以上两点原因，建议将执行时间较长的inline脚本异步执行，异步的方式有很多种，例如使用script元素的defer属性（存在兼容性问题和其他一些问题，例如不能使用document.write）、使用setTimeout，此外，在HTML5中引入了[Web Workers](https://developer.mozilla.org/En/Using_web_workers)的机制，恰恰可以解决此类问题。

**4\. Lazy Load Javascript**

随着**Javascript**框架的流行，越来越多的站点也使用起了框架。不过，一个框架往往包括了很多的功能实现，这些功能并不是每一个页面都需要的，如果下载了不需要的脚本则算得上是一种资源浪费-既浪费了带宽又浪费了执行花费的时间。目前的做法大概有两种，一种是为那些流量特别大的页面专门定制一个专用的mini版框架，另一种则是Lazy Load。[YUI](http://developer.yahoo.com/yui/3/)则使用了第二种方式，在**YUI**的实现中，最初只加载核心模块，其他模块可以等到需要使用的时候才加载。

**5\. 将CSS放在HEAD中**

如果将CSS放在其他地方比如BODY中，则浏览器有可能还未下载和解析到CSS就已经开始渲染页面了，这就导致页面由无CSS状态跳转到CSS状态，用户体验比较糟糕。除此之外，有些浏览器会在CSS下载完成后才开始渲染页面，如果CSS放在靠下的位置则会导致浏览器将渲染时间推迟。

**6\. 异步请求Callback**

在某些页面中可能存在这样一种需求，需要使用script标签来异步的请求数据。类似：
Javascript:
<pre lang="javascript">function myCallback(info){
//do something here
}</pre>
HTML
<pre lang="html"><script src="http://abc.com/cb" type="text/javascript"></script></pre>
callback返回的内容:
`myCallback('Hello world!'); `

像以上这种方式直接在页面上写&lt;script&gt;对页面的性能也是有影响的，即增加了页面首次加载的负担，推迟了DOMLoaded和window.onload事件的触发时机。如果时效性允许的话，可以考虑在DOMLoaded事件触发的时候加载，或者使用setTimeout方式来灵活的控制加载的时机。

**7\. 减少不必要的HTTP跳转**

对于以目录形式访问的HTTP链接，很多人都会忽略链接最后是否带’/'，假如你的服务器对此是区别对待的话，那么你也需要注意，这其中很可能隐藏了301跳转，增加了多余请求。具体参见下图，其中第一个链接是以无’/'结尾的方式访问的，于是服务器有了一次跳转。

[caption id="attachment_615" align="aligncenter" width="244" caption="图1.3"][![图1.3](http://js8.in/wp-content/uploads/2010/08/image-thumb2.png "图1.3")](http://js8.in/wp-content/uploads/2010/08/image-thumb2.png)[/caption]

**8\. 避免重复的资源请求**

这种情况主要是由于疏忽或页面由多个模块拼接而成，然后每个模块中请求了同样的资源时，会导致资源的重复请求。出现的几率不大，但是还是要注意排查，不然可能会出现如下局面，来自[这里](http://womai.com/)。

[caption id="attachment_616" align="aligncenter" width="244" caption="图1.4"][![图1.4](http://js8.in/wp-content/uploads/2010/08/image-thumb3.png "图1.4")](http://js8.in/wp-content/uploads/2010/08/image-thumb3.png)[/caption]

图1.4中，同一个JS在一个页面中请求了9次，全是200请求，当然这个算比较极端的情况了。

### 二、代码级优化

**1\. Javascript**

(1). DOM

DOM操作应该是脚本中最耗性能的一类操作，例如增加、修改、删除DOM元素或者对DOM集合进行操作。如果脚本中包含了大量的DOM操作则需要注意以下几点：

a. HTML Collection

在脚本中document.images、document.forms、getElementsByTagName()返回的都是HTMLCollection类型的集合，在平时使用的时候大多将它作为数组来使用，因为它有length属性，也可以使用索引访问每一个元素。不过在访问性能上则比数组要差很多，原因是这个集合并不是一个静态的结果，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个查询从而更新查询结果。所谓的“访问集合”包括读取集合的length属性、访问集合中的元素。

因此，当你需要遍历HTML Collection的时候，尽量将它转为数组后再访问，以提高性能。即使不转换为数组，也请尽可能少的访问它，例如在遍历的时候可以将length属性、成员保存到局部变量后再使用局部变量。

b. Reflow &amp; Repaint

除了上面一点之外，DOM操作还需要考虑浏览器的Reflow和Repaint，因为这些都是需要消耗资源的，具体的可以参加以下文章：

[ 如何减少浏览器的repaint和reflow?](http://varnow.org/?p=232)

[ Understanding Internet Explorer Rendering Behaviour](http://blog.dynatrace.com/2009/12/12/understanding-internet-explorer-rendering-behaviour/)

[ Notes on HTML Reflow](http://www.mozilla.org/newlayout/doc/reflow.html)

(2). 慎用with

`with(obj){ p = 1}; `代码块的行为实际上是修改了代码块中的执行环境，将obj放在了其作用域链的最前端，在with代码块中访问非局部变量是都是先从obj上开始查找，如果没有再依次按作用域链向上查找，因此使用with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的，过长的作用域链会导致查找性能下降。

因此，除非你能肯定在with代码中只访问obj中的属性，否则慎用with，替代的可以使用局部变量缓存需要访问的属性。

(3). 避免使用eval和Function

每次 eval 或 Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操作 —— 通常比简单的函数调用慢100倍以上。

eval 函数效率特别低，由于事先无法知晓传给 eval 的字符串中的内容，eval在其上下文中解释要处理的代码，也就是说编译器无法优化上下文，因此只能有浏览器在运行时解释代码。这对性能影响很大。

Function 构造函数比eval略好，因为使用此代码不会影响周围代码；但其速度仍很慢。

此外，使用eval和Function也不利于Javascript压缩工具执行压缩。

(4). 减少作用域链查找

前文谈到了作用域链查找问题，这一点在循环中是尤其需要注意的问题。如果在循环中需要访问非本作用域下的变量时请在遍历之前用局部变量缓存该变量，并在遍历结束后再重写那个变量，这一点对全局变量尤其重要，因为全局变量处于作用域链的最顶端，访问时的查找次数是最多的。

低效率的写法：
<pre lang="javascript">//全局变量
var globalVar = 1;
function myCallback(info){
for( var i = 100000; i--;){
//每次访问globalVar都需要查找到作用域链最顶端，本例中需要访问100000次
globalVar += i;
}
}</pre>
更高效的写法：
<pre lang="javascript">//全局变量
var globalVar = 1;
function myCallback(info){
//局部变量缓存全局变量
var localVar = globalVar;
for( var i = 100000; i--;){
//访问局部变量是最快的
localVar += i;
}
//本例中只需要访问2次全局变量
globalVar = localVar;
}</pre>
此外，要减少作用域链查找还应该减少闭包的使用。

(5). 数据访问

Javascript中的数据访问包括直接量（字符串、正则表达式）、变量、对象属性以及数组，其中对直接量和局部变量的访问是最快的，对对象属性以及数组的访问需要更大的开销。当出现以下情况时，建议将数据放入局部变量：

1.  对任何对象属性的访问超过1次
2.  对任何数组成员的访问次数超过1次
另外，还应当尽可能的减少对对象以及数组深度查找。

(6). 字符串拼接

在Javascript中使用"+"号来拼接字符串效率是比较低的，因为每次运行都会开辟新的内存并生成新的字符串变量，然后将拼接结果赋值给新变量。与之相比更为高效的做法是使用数组的join方法，即将需要拼接的字符串放在数组中最后调用其join方法得到结果。不过由于使用数组也有一定的开销，因此当需要拼接的字符串较多的时候可以考虑用此方法。

关于Javascript优化的更详细介绍请参考：

[ Write Efficient Javascript(PPT)](http://www.slideshare.net/nzakas/writing-efficient-javascript)

[ Efficient JavaScript](http://dev.opera.com/articles/view/efficient-javascript/)

[javascript高效简洁代码的编写及优化技巧](http://js8.in/350.html "javascript高效简洁代码的编写及优化技巧- 断桥残雪部落格")

**2\. CSS选择符**

在大多数人的观念中，都觉得浏览器对CSS选择符的解析式从左往右进行的，例如
<pre lang="css">#toc A { color: #444; }</pre>
这样一个选择符，如果是从右往左解析则效率会很高，因为第一个ID选择基本上就把查找的范围限定了，但实际上浏览器对选择符的解析是从右往左进行的。如上面的选择符，浏览器必须遍历查找每一个A标签的祖先节点，效率并不像之前想象的那样高。根据浏览器的这一行为特点，在写选择符的时候需要注意很多事项，有人已经一一列举了，[详情参考此处](https://developer.mozilla.org/en/Writing_Efficient_CSS)。

**3\. HTML**

对HTML本身的优化现如今也越来越多的受人关注了，详情可以参见这篇[总结性文章](http://varnow.org/?p=249)。

**4\. Image压缩**

图片压缩是个技术活，不过现如今这方面的工具也非常多，压缩之后往往能带来不错的效果，具体的压缩原理以及方法在《Even Faster Web Sites》第10章有很详细的介绍，有兴趣的可以去看看。

### 总结

本文从页面级以及代码级两个粒度对**前端优化**的各种方式做了一个总结，这些方法基本上都是前端开发人员在开发的过程中可以借鉴和实践的，除此之外，完整的前端优化还应该包括很多其他的途径，例如CDN、Gzip、多域名、无Cookie服务器等等，由于对于开发人员的可操作性并不强大，在此也就不多叙述了，详细的可以参考[Yahoo](http://developer.yahoo.com/performance/rules.html)和[Google](http://code.google.com/speed/page-speed/docs/rules_intro.html)的这些“金科玉律”。

原文链接：http://varnow.org/?p=260

[caption id="attachment_590" align="aligncenter" width="147" caption="感觉不错,订阅它"][![断桥残雪部落格最新的订阅地址](http://js8.in/wp-content/uploads/2010/08/logo_147x47.gif "断桥残雪部落格最新的订阅地址")](http://feed.feedsky.com/r57c)[/caption] 