<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 6 页 - 归档 - 三水清</title>
  <meta name="author" content="三水清">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="三水清"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="atom.xml" title="三水清" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">三水清</a></h1>
  <h2><a href="/">专注前端开发,分享Javascript/CSS/PHP等Web前端开发技巧</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/about">关于</a></li>
    
      <li><a href="https://github.com/ksky521">Github</a></li>
    
      <li><a href="http://weibo.com/sanshuiqing">新浪微博</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title">归档</h2>


  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
      
      
  
    <h1 class="title"><a href="/2011/10/18/html5的sessionstorage和localstorage/">HTMl5的sessionStorage和localStorage</a></h1>
  

      <time datetime="2011-10-18T14:05:53.000Z"><a href="/2011/10/18/html5的sessionstorage和localstorage/">2011年10月18日</a></time>
    </header>
    <div class="entry">
      
        <p>html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。</p>
<p><strong>sessionStorage</strong>用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。</p>
<p>而<strong>localStorage</strong>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p>
<h2>web storage和cookie的区别</h2>
<p>Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。</p>
<p>除此之外，<strong>Web Storage</strong>拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。</p>
<p>但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生（来自@otakustay 的纠正）</p>
<h2>html5 web storage的浏览器支持情况</h2>
<p>浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的UserData其实就是<strong>javascript本地存储</strong>的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。</p>
<p>要判断浏览器是否支持localStorage可以使用下面的代码：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">if</span>(window.localStorage){
    alert(<span class="string">"浏览支持localStorage"</span>)
}<span class="keyword">else</span>{
   alert(<span class="string">"浏览暂不支持localStorage"</span>)
}
<span class="comment">//或者</span>
<span class="keyword">if</span>(<span class="keyword">typeof</span> window.localStorage == <span class="string">'undefined'</span>){
	alert(<span class="string">"浏览暂不支持localStorage"</span>)
}
</pre></td></tr></table></figure>

<h2>localStorage和sessionStorage操作</h2>
<p>localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等</p>
<h3>localStorage和sessionStorage的方法</h3>
<h4>setItem存储value</h4>
<p>用途：将value存储到key字段<br>用法：.setItem( key, value)</p>
<p>代码示例：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>sessionStorage.setItem(<span class="string">"key"</span>, <span class="string">"value"</span>);
localStorage.setItem(<span class="string">"site"</span>, <span class="string">"js8.in"</span>);
</pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2011/10/18/html5的sessionstorage和localstorage/#more" class="more-link">全文</a>
          </div>
        
        
      
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
      
      
  
    <h1 class="title"><a href="/2011/09/29/基于expresssocket-io的nodejs聊天室/">基于express+socket.io的nodejs聊天室</a></h1>
  

      <time datetime="2011-09-29T15:20:24.000Z"><a href="/2011/09/29/基于expresssocket-io的nodejs聊天室/">2011年9月29日</a></time>
    </header>
    <div class="entry">
      
        <p>前几天晚上边看水浒边写的<a href="http://js8.in/tag/nodejs">nodejs</a>的聊天室，前面说了，放假之前要把近日学习nodejs的所有心得整理下，今天就是30号鸟~撒欢~，最后放这个聊天室出来给大家作为学习<strong>nodejs</strong>的参考示例，希望对大家有用。</p>
<p>感谢：cnodejs群里的老雷，及其<a href="http://weibo.com/sanshuiqing" target="_blank">微博</a>上的基友们！顺祝大家长假快乐，顺祝自己明天动车不出轨，顺祝明年不再过节，感慨多了……</p>
<h3>特点</h3>
<p>聊天室主要功能及其特点：</p>
<ol>
<li>采用nodejs（屁话）</li>
<li>express框架,jade做模板</li>
<li>socket.io做前后端的websocket通信</li>
<li>支持session</li>
<li>支持@私信功能<br>废话不多说了，注意点，基本前面的文章都提到了，下面罗列下：<br>《<a href="http://js8.in/764.html">配置nodejs.exe的windows目录结构</a>》<br>《<a href="http://js8.in/774.html">安装express及配置app.js文件</a>》<br>《<a href="http://js8.in/784.html">使用socket.io和node.js搭建websocket应用</a>》<br>《<a href="http://js8.in/788.html">在Express和Socket.IO中使用session</a>》</li>
</ol>
<h3>nodejs聊天室下载地址</h3>
<p><a href="http://1.nodejsdemo.sinaapp.com/chat/chat.zip" title="基于express+socket.io的聊天室" target="_blank">基于express+socket.io的聊天室</a></p>
<h3>聊天室服务器端js代码</h3>
<p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2011/09/29/基于expresssocket-io的nodejs聊天室/#more" class="more-link">全文</a>
          </div>
        
        
      
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
      
      
  
    <h1 class="title"><a href="/2011/09/29/在express和socket-io中使用session/">在Express和Socket.IO中使用session</a></h1>
  

      <time datetime="2011-09-29T14:32:53.000Z"><a href="/2011/09/29/在express和socket-io中使用session/">2011年9月29日</a></time>
    </header>
    <div class="entry">
      
        <p>在nodejs项目中对于一些认证需要用到<strong>session</strong>，例如我写的nodejs 聊天室的demo，就是通过session实现的认证。当存在session，直接进入聊天室，而不会重新登录。</p>
<p>在网上也找到不少关于Express框架中的session调用方法，可是发现真正能用的不是很多，今天根据聊天室的制作过程，整理下Express和socket.IO中使用session的具体方法。</p>
<p>Express的session是通过cookie实现的，用到了connect中的两个module：parseCookie和MemoryStore，前者是用来解析cookie，后者用来存储sesion。</p>
<h2>引入所需module</h2>
<p>Express框架中使用session必须先引入上面的两个模块，例如下面的代码：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">var</span> parseCookie = require(<span class="string">'connect'</span>).utils.parseCookie,
	MemoryStore = require(<span class="string">'connect/middleware/session/memory'</span>);
<span class="comment">//建立一个memory store的实例</span>
<span class="keyword">var</span> storeMemory = <span class="keyword">new</span> MemoryStore({
		reapInterval: <span class="number">60000</span> * <span class="number">10</span>
	});
</pre></td></tr></table></figure>

<h2>Express中app的配置</h2>
<p>在app需要添加如下的配置：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>app.configure(<span class="keyword">function</span>(){
	app.use(express.bodyParser());<span class="comment">//解析post</span>
	app.use(express.cookieParser());<span class="comment">//解析cookie</span>
	<span class="comment">//设置session</span>
	app.use(express.session({
		secret: <span class="string">'wyq'</span>,
		store:storeMemory
	}));
});
</pre></td></tr></table></figure>

<h2>在请求中使用session</h2>
<p>在请求中我们可以使用request.session来调用session，例如下面的代码：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>app.get(<span class="string">'/'</span>,<span class="keyword">function</span>(req,res){
	<span class="comment">//使用request.session来判断是否登录</span>
	<span class="keyword">if</span>( req.session.name && req.session.name!==<span class="string">''</span>){
		<span class="comment">//需要判断下是否已经登录</span>
		res.redirect(<span class="string">'/chat'</span>);
	}<span class="keyword">else</span>{
		<span class="comment">//读取登录页面，要求登录</span>
		<span class="keyword">var</span> realpath = __dirname + <span class="string">'/views/'</span> + url.parse(<span class="string">'login.html'</span>).pathname;
		<span class="keyword">var</span> txt = fs.readFileSync(realpath);
		res.end(txt);
	}
});
</pre></td></tr></table></figure>

<h2>websocket通信中使用session</h2>
<p>在nodejs项目中，我们常常使用websockt来实现通信，所以websocket中也需要通过session来认证用户。本例使用socket.io来举例实现nodejs中websocket通信session的认证。关于socket.io的使用参考文章《<a href="http://js8.in/784.html">使用socket.io和node.js搭建websocket应用</a>》</p>
<p>上面代码中引入了解析cookie的<strong>parseCookie</strong>，所以session是通过cookie来解析的。首先我们建立了socket的监听之后需要对监听到的头文件处理，解析出来cookie中的session。例如下面的代码：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="keyword">var</span> io = sio.listen(app);
<span class="comment">//设置session</span>
io.set(<span class="string">'authorization'</span>, <span class="keyword">function</span>(handshakeData, callback){
	<span class="comment">// 通过客户端的cookie字符串来获取其session数据</span>
	handshakeData.cookie = parseCookie(handshakeData.headers.cookie)
	<span class="keyword">var</span> connect_sid = handshakeData.cookie[<span class="string">'connect.sid'</span>];
	<span class="keyword">if</span> (connect_sid) {
		storeMemory.get(connect_sid, <span class="keyword">function</span>(error, session){
			<span class="keyword">if</span> (error) {
				<span class="comment">// if we cannot grab a session, turn down the connection</span>
				callback(error.message, <span class="literal">false</span>);
			}
			<span class="keyword">else</span> {
				<span class="comment">// save the session data and accept the connection</span>
				handshakeData.session = session;
				callback(<span class="literal">null</span>, <span class="literal">true</span>);
			}
		});
	}
	<span class="keyword">else</span> {
		callback(<span class="string">'nosession'</span>);
	}
});
</pre></td></tr></table></figure>

<p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2011/09/29/在express和socket-io中使用session/#more" class="more-link">全文</a>
          </div>
        
        
      
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
      
      
  
    <h1 class="title"><a href="/2011/09/28/使用socket-io和node-js搭建websocket应用/">使用socket.io和node.js搭建websocket应用</a></h1>
  

      <time datetime="2011-09-28T15:42:21.000Z"><a href="/2011/09/28/使用socket-io和node-js搭建websocket应用/">2011年9月28日</a></time>
    </header>
    <div class="entry">
      
        <p><strong>websocket</strong>是HTML5的一种新的通信协议，它是实现了浏览器与服务器的双向通讯。在 WebSocket API 中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。<br>关于websocket的更多信息，请移步<a href="http://zh.wikipedia.org/wiki/WebSocket" target="_blank">维基百科</a></p>
<h2>使用WebSocket</h2>
<p>在客户端使用websocket需要创建WebSocket对象，通过提供的open、send、message、close等方法实现创建、发送、监听信息、关闭连接。例如下面的代码：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">if</span>(<span class="string">'WebSocket'</span> <span class="keyword">in</span> window){
	<span class="comment">// 创建websocket实例</span>
	<span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);
	<span class="comment">//打开</span>
	socket.onopen = <span class="keyword">function</span>(event) {
	  <span class="comment">// 发送</span>
	  socket.send(<span class="string">'I am the client and I\'m listening!'</span>);
	  <span class="comment">// 监听</span>
	  socket.onmessage = <span class="keyword">function</span>(event) {
		console.log(<span class="string">'Client received a message'</span>,event);
	  };
	  <span class="comment">// 关闭监听</span>
	  socket.onclose = <span class="keyword">function</span>(event) {
		console.log(<span class="string">'Client notified socket has closed'</span>,event);
	  };
	  <span class="comment">// 关闭</span>
	  <span class="comment">//socket.close()</span>
	};
}<span class="keyword">else</span>{
	alert(<span class="string">'本浏览器不支持WebSocket哦~'</span>);
}
</pre></td></tr></table></figure>

<p>现在chrome、firefox等浏览器都已经支持了websocket，而IE却没有。下面我们来简单说说服务器端对websocket的支持。</p>
<p>服务器端支持<strong>websocket</strong>的语言不少，而且都有相关的开源项目，例如php的phpwebsockets：<a href="http://code.google.com/p/phpwebsockets/" target="_blank"><a href="http://code.google.com/p/phpwebsockets/">http://code.google.com/p/phpwebsockets/</a></a>，java的jWebsocket：<a href="http://jwebsocket.org/" target="_blank"><a href="http://jwebsocket.org/">http://jwebsocket.org/</a></a>。<br>更多的信息可以浏览这篇文章：<a href="http://net.tutsplus.com/tutorials/javascript-ajax/start-using-html5-websockets-today/" target="_blank">Start Using HTML5 WebSockets Today</a></p>
<h2>socket.io</h2>
<p><strong>socket.IO</strong>是一个websocket库，包括了客户端的js和服务器端的nodejs。官方地址：<a href="http://socket.io" target="_blank"><a href="http://socket.io">http://socket.io</a></a></p>
<h3>客户端使用socket.io</h3>
<p>去github clone socket.io的最新版本，或者直接饮用使用socket.io的CDN服务：</p>
<figure class="highlight lang-html"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://cdn.socket.io/stable/socket.io.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>

<p>下面可以创建使用socket.io库来创建客户端js代码了：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> socket = io.connect(<span class="string">'http://localhost'</span>);
socket.on(<span class="string">'news'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span>
	console.log(data);
	socket.emit(<span class="string">'my other event'</span>, { my: <span class="string">'data'</span> });
});
</pre></td></tr></table></figure>

<p>socket.on是监听，收到服务器端发来的news的内容，则运行function，其中data就是请求回来的数据，socket.emit是发送消息给服务器端的方法。</p>
<h3>使用socket.io和nodejs搭建websocket服务器端</h3>
<p>socket.io不仅可以搭建客户端的websocket服务，而且支持nodejs服务器端的websocket。</p>
<h3>nodejs安装socket.io</h3>
<p>使用node插件管理包，运行下面的命令就可以安装成功socket.io</p>
<blockquote>
<p>npm install socket.io</p>
</blockquote>
<p>没有npm的或者windows用户可以使用github下载socket.io并且放入到node_modules文件夹中，具体配置可以参考文章：《nodejs教程：配置nodejs.exe的windows目录结构》</p>
<h3>nodejs建立socket.io服务</h3>
<p>通过nodejs的http模块就可以方便的搭建websocket服务器环境，例如下面的代码：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre>// 引入需要的模块：http和socket.io
var http = require('http'), io = require('socket.io');
//创建server
var server = http.createServer(function(req, res){
  // Send HTML headers and message
  res.writeHead(200,{ 'Content-Type': 'text/html' });
  res.end('

# Hello Socket Lover!
');
});
//端口8000
server.listen(8080);
//创建socket
var socket = io.listen(server);
//添加连接监听
socket.on('connection', function(client){
	//连接成功则执行下面的监听
	client.on('message',function(event){
		console.log('Received message from client!',event);
	});
	//断开连接callback
	client.on('disconnect',function(){
		console.log('Server has disconnected');
	});
});
</pre></td></tr></table></figure>

<p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2011/09/28/使用socket-io和node-js搭建websocket应用/#more" class="more-link">全文</a>
          </div>
        
        
      
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
      
      
  
    <h1 class="title"><a href="/2011/09/27/javascript获取隐藏dom的宽高/">javascript获取隐藏dom的宽高</a></h1>
  

      <time datetime="2011-09-27T14:50:15.000Z"><a href="/2011/09/27/javascript获取隐藏dom的宽高/">2011年9月27日</a></time>
    </header>
    <div class="entry">
      
        <p>一个隐藏的DOM是获取不到宽高的，如果想要获取，采用下面的方法：<br>首先clone一个DOM，设置<code>position:absolute</code>，然后设置top为一个比较大的负值，然后使其显示出来，最后获取到了DOM的宽高后，将其remove。</p>
<p>具体代码如下：<br>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2011/09/27/javascript获取隐藏dom的宽高/#more" class="more-link">全文</a>
          </div>
        
        
      
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
      
      
  
    <h1 class="title"><a href="/2011/09/27/nodejs教程：安装express即配置app-js文件/">nodejs教程：安装express及配置app.js文件</a></h1>
  

      <time datetime="2011-09-26T22:35:52.000Z"><a href="/2011/09/27/nodejs教程：安装express即配置app-js文件/">2011年9月27日</a></time>
    </header>
    <div class="entry">
      
        <p><strong>express.js</strong>是nodejs的一个MVC开发框架，并且支持jade等多种模板。下面简单来说说express的安装和app.js文件的配置，然后在今后的教程中一步一步使用express.js搭建个聊天室。</p>
<h2>安装express.js</h2>
<p>如果你安装了npm，安装变得很简单，只需要在终端中运行下面的代码即可：</p>
<blockquote>
<p>npm install express -gd<br>-g代表安装到NODE_PATH的lib里面，而-d代表把相依性套件也一起安装。如果沒有-g的话会安装目前所在的目录(会建立一个node_modules的文件夹)，你可以透过以下指令来比较两者的不同：</p>
<p>npm list -g<br>npm list</p>
</blockquote>
<p>如果没有npm，那么我可以使用github来git下来最新的express。<br>好了，现在你可以通过<code>express testapp</code>来建立express实例。以下是示例：</p>
<blockquote>
<p>cd ~<br>express testapp<br>cd testapp<br>node app.js<br>这样就建立了一个testapp的<strong>nodejs</strong>应用，而app.js是默认的应用主js。下面来详细的说说app.js中的各项配置。</p>
</blockquote>
<h2>引入模块</h2>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">var</span> express = require(<span class="string">'express'</span>);
 <span class="keyword">var</span> app = module.exports = express.createServer();
</pre></td></tr></table></figure>

<p>require()是node.js提供的函数，可以让你引入其他模块以调用模块的函数和变量，默认下node.js会在$NODE_PATH和目前js所在目录下的node_modules文件夹下去寻找模块。require也可以用来载入自己写的模块哦~这样涉及到node.js的模块机制，后面有机会就在介绍。</p>
<p>第二行的express.createServer()就是在建立server，而中间的module.exports也是涉及到node.js的模块机制，以后再说。</p>
<h2>express的app.js的详细配置说明</h2>
<p>express.js继承自connect模块，所以如果你的node_modules文件夹下没有connect模块也是不行的。</p>
<h3>设置views路径和模板</h3>
<p>我们再来看下面两行：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>app.set(<span class="string">'views'</span>, __dirname + <span class="string">'/views'</span>);
app.set(<span class="string">'view engine'</span>, <span class="string">'jade'</span>);
</pre></td></tr></table></figure>

<p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2011/09/27/nodejs教程：安装express即配置app-js文件/#more" class="more-link">全文</a>
          </div>
        
        
      
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
      
      
  
    <h1 class="title"><a href="/2011/09/08/使用html5-postmessage和window-name实现多浏览器跨域/">使用html5 postMessage和window.name实现多浏览器跨域</a></h1>
  

      <time datetime="2011-09-07T17:40:30.000Z"><a href="/2011/09/08/使用html5-postmessage和window-name实现多浏览器跨域/">2011年9月8日</a></time>
    </header>
    <div class="entry">
      
        <p><strong>跨域</strong>是个“很古老”的问题，因为浏览器的同源策略，导致不同域名下不能进行跨域名请求数据，虽然这样设计安全了很多，但是对于大型的网站同时维护多个域名就需要进行跨域操作。例如：微博开放平台的jssdk实现的跨域请求数据，再例如weibo.com和sina.com的同步登录。</p>
<p>之前我也说过不少跨域的方式了，有结合服务器端的，有纯粹javascript实现的跨域，例如：《<a href="http://js8.in/685.html">利用跨域资源共享（CORS）实现ajax跨域调用</a>》、《<a href="http://js8.in/443.html">用document.domain+iframe实现Ajax跨子域</a>》、《<a href="http://js8.in/548.html">通过JSONP实现完美跨域</a>》。在我的上一篇文章《<a href="http://js8.in/750.html">javascript入门到高级PPT</a>》中也提到了跨域。<br>当然也有不少关于跨域的文章，例如口碑UED的文章《<a href="http://ued.koubei.com/?p=1291" target="_blank">跨域资源共享的10种方式</a>》等等。大家可以去阅读一下。</p>
<p>今天我说的html5 <strong>postMessage</strong>和window.name也不是一种新的跨域方式，因为有不少人写文章写了，而实际应用的我不知道有哪些人？不过新浪微博的新旧两个jssdk都是采用这种方式，包括之前的人人网的xd.html，当然现在的人人和facebook都是通过flash实现的跨域，这不是今天说的内容。</p>
<h3>html5 postMessage实现跨域</h3>
<p>postMessage是html5的一个新功能，可以实现不同域名之间的通信，通过给postMessage方式发送数据，监听则通过在父子窗口添加onmessage事件进行。<br>缺点也就很明显了，只有支持html5的浏览器才支持这种跨域方式，像IE6、7当然就拒之门外了！</p>
<h3>window.name实现跨域</h3>
<p>window.name实现跨域也是一个比较老的问题，之前<a href="http://hikejun.com/blog/?p=56" target="_blank">kejun</a>写过一个<a href="http://hikejun.com/demo/windowname/demo_windowname.html" target="_blank">demo</a>，可是给的却是同域名的通信。<br>其实kejun的实例中就是实现跨域的，不过他采用了同一个域名，而且过程比较崎岖：</p>
<ol>
<li>建立iframe，指定src为被跨域的页面</li>
<li>被跨域文件修改window.name，将数据传给window.name</li>
<li>将iframe.src修改为本域代理文件，然后就可以取到contentWindow.name</li>
<li>进行处理数据，清除iframe<br>充分的运用了<strong>window.name</strong>因为页面的url改变而name不改变的特性。<br>但是如果我们是自己用，还是可以的，而如果我们放出去要别人使用我们写的东西，那样学习成本太大。</li>
</ol>
<h3>多浏览器双向跨域</h3>
<p>为了解决上面的问题，我们使用的方法就是如果支持<strong>postMessage</strong>的浏览器就使用postMessage，如果不支持的就采用window.name的方式，幸运的是在IE6、7中支持跨域设置window.name，而我们就可以简单的通过window.name来<strong>跨域</strong>。然后建立计时器来监听window.name是否发生了变化，如果变化则接收并分析window.name，然后做请求。<br>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2011/09/08/使用html5-postmessage和window-name实现多浏览器跨域/#more" class="more-link">全文</a>
          </div>
        
        
      
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
      
      
  
    <h1 class="title"><a href="/2011/08/27/javascript入门到高级ppt/">javascript入门到高级PPT</a></h1>
  

      <time datetime="2011-08-27T14:10:20.000Z"><a href="/2011/08/27/javascript入门到高级ppt/">2011年8月27日</a></time>
    </header>
    <div class="entry">
      
        <p>前些日子参加了公司RIA的实习生和新员工的<strong>javascript</strong>培训课程，做了个PPT，今天拿来跟大家分享下，高手飘过，欢迎拍砖。<br>本课程分了两段，第一部分是javascript入门基础和中级教程，后面是高级，讲到了javascript的作用域链和原型链，以及javascript面向对象的继承写法，最后简单提了一下前端安全，最后简单介绍了下前端的发展和展望，要新员工开阔下眼界，同时提供了一些学习的资源和RSS源。<br>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2011/08/27/javascript入门到高级ppt/#more" class="more-link">全文</a>
          </div>
        
        
      
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
      
      
  
    <h1 class="title"><a href="/2011/08/15/javascript的词法作用域/">javascript的词法作用域</a></h1>
  

      <time datetime="2011-08-15T08:35:22.000Z"><a href="/2011/08/15/javascript的词法作用域/">2011年8月15日</a></time>
    </header>
    <div class="entry">
      
        <p>大家应该写过下面类似的代码吧，其实这里我想要表达的是有时候一个方法定义的地方和使用的地方会相隔十万八千里，那方法执行时，它能访问哪些变量，不能访问哪些变量，这个怎么判断呢？这个就是我们这次需要分析的问题——<strong>词法作用域</strong></p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">var</span> classA = <span class="keyword">function</span>(){
    <span class="keyword">this</span>.prop1 = <span class="number">1</span>;
}
classA.prototype.func1 = <span class="keyword">function</span>(){
    <span class="keyword">var</span> that = <span class="keyword">this</span>,
        var1 = <span class="number">2</span>;

    <span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span>{</span>
        <span class="keyword">return</span> <span class="keyword">function</span>(){
            alert(var1);
            alert(<span class="keyword">this</span>.prop1);
        }.apply(that);
    };
    a();
}
<span class="keyword">var</span> objA = <span class="keyword">new</span> ClassA();
objA.func1();
</pre></td></tr></table></figure>

<p><strong>词法作用域</strong>：变量的作用域是在定义时决定而不是执行时决定，也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。 with和eval除外，所以只能说JS的作用域机制非常接近词法作用域（Lexical scope）。</p>
<p>下面通过几个小小的案例，开始深入的了解对理解词法作用域和<strong>闭包</strong>必不可少的，JS执行时底层的一些概念和理论知识。</p>
<h2>经典案列重现</h2>
<h4>1、经典案例一</h4>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">/*全局（window）域下的一段代码*/</span>
<span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">(i)</span> {</span>
    <span class="keyword">var</span> i;
    alert(i);
};
a(<span class="number">10</span>);
</pre></td></tr></table></figure>

<p>疑问：上面的代码会输出什么呢？<br>答案：没错，就是弹出10。具体执行过程应该是这样的</p>
<blockquote>
<p>a 函数有一个形参 i，调用 a 函数时传入实参 10，形参 i=10<br>接着定义一个同名的局部变量 i，未赋值<br>alert 输出 10</p>
</blockquote>
<p>思考：局部变量 i 和形参 i 是同一个存储空间吗？</p>
<h4>2、经典案例二</h4>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">/*全局（window）域下的一段代码*/</span>
<span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">(i)</span> {</span>
    alert(i);
    alert(arguments[<span class="number">0</span>]); <span class="comment">//arguments[0]应该就是形参 i</span>
    <span class="keyword">var</span> i = <span class="number">2</span>;
    alert(i);
    alert(arguments[<span class="number">0</span>]);
};
a(<span class="number">10</span>);
</pre></td></tr></table></figure>

<p>疑问：上面的代码又会输出什么呢？（（ 10,10,2,10 || 10,10,2,2 ））<br>答案：在FireBug中的运行结果是第二个10,10,2,2，猜对了… ，下面简单说一下具体执行过程<br>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2011/08/15/javascript的词法作用域/#more" class="more-link">全文</a>
          </div>
        
        
      
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
      
      
  
    <h1 class="title"><a href="/2011/08/11/javascript变量类型/">javascript变量类型</a></h1>
  

      <time datetime="2011-08-11T12:51:09.000Z"><a href="/2011/08/11/javascript变量类型/">2011年8月11日</a></time>
    </header>
    <div class="entry">
      
        <p>javascript的<strong>变量类型</strong>真的很要人纠结，即使你是很有经验的js工程师，你也很难说清楚js的类型和分类。<br>最近在讲javascript入门指南的时候，有人提出数组为什么不是基本类型，我通过演示<code>typeof []</code>的结果来说明，数组是对象类型派生出来的，而不是六种基本类型。<br>其实要理解javascript的变量类型很简单，就是我们要找到一个划分的标准。</p>
<h2>javascript变量类型分类</h2>
<p>在很多书中都提到了javascript的变量类型，每本书都有不同的划分标准，如果按照typeof和instanceof的返回值来区分，可以把javascript的变量类型分为两套类型系统：基本类型和对象类型衍生出来的对象类型系统。<br>基本类型包括：undefined，number，boolean，string，object，function，他们之前通过typeof的返回值来区分。<br>第二套对象类型系统是由第一套系统衍生发展而来的，例如前面提到的Array，还有Null，Number，Boolean等等，对象类型可以通过<strong>instanceof</strong>来判断。<br>那么对象类型中的Number和基本类型中的number又是什么关系呢？他们又是什么区别呢？<br>答案就是，他们是映射关系，即下例：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> a = <span class="keyword">new</span> Number(<span class="number">123</span>);
console.log(a.valueOf()===<span class="number">123</span>);<span class="comment">//true</span>
<span class="keyword">var</span> b = <span class="keyword">new</span> String(<span class="number">123</span>);
console.log(b.valueOf()===<span class="number">123</span>);<span class="comment">//false</span>
console.log(b.valueOf()===<span class="string">'123'</span>);<span class="comment">//true</span>
</pre></td></tr></table></figure>

<p>obj.valueOf()返回的是该对象的原始值。</p>
<h2>值类型和引用类型</h2>
<p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2011/08/11/javascript变量类型/#more" class="more-link">全文</a>
          </div>
        
        
      
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  

  <nav id="pagination">
  
    <a href="/archives/page/5/" class="alignleft prev">上一页</a>
  
  
    <a href="/archives/page/7/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/乱七八糟/">乱七八糟</a><small>30</small></li>
  
    <li><a href="/categories/前端开发/">前端开发</a><small>117</small></li>
  
    <li><a href="/categories/后端运维/">后端运维</a><small>27</small></li>
  
    <li><a href="/categories/王婆卖瓜/">王婆卖瓜</a><small>4</small></li>
  
    <li><a href="/categories/读书笔记/">读书笔记</a><small>5</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签</h3>
  <ul class="entry clearfix">
  
    <li><a href="/tags/DOM/">DOM<sup>2</sup></a></li>
  
    <li><a href="/tags/IE/">IE<sup>1</sup></a></li>
  
    <li><a href="/tags/IE6/">IE6<sup>2</sup></a></li>
  
    <li><a href="/tags/PPT/">PPT<sup>3</sup></a></li>
  
    <li><a href="/tags/VPS/">VPS<sup>1</sup></a></li>
  
    <li><a href="/tags/ajax/">ajax<sup>5</sup></a></li>
  
    <li><a href="/tags/apache/">apache<sup>1</sup></a></li>
  
    <li><a href="/tags/audio/">audio<sup>2</sup></a></li>
  
    <li><a href="/tags/a标签/">a标签<sup>1</sup></a></li>
  
    <li><a href="/tags/canvas/">canvas<sup>1</sup></a></li>
  
    <li><a href="/tags/chrome/">chrome<sup>3</sup></a></li>
  
    <li><a href="/tags/css/">css<sup>15</sup></a></li>
  
    <li><a href="/tags/eAccelerator/">eAccelerator<sup>1</sup></a></li>
  
    <li><a href="/tags/ecmascript/">ecmascript<sup>3</sup></a></li>
  
    <li><a href="/tags/escape/">escape<sup>1</sup></a></li>
  
    <li><a href="/tags/event/">event<sup>1</sup></a></li>
  
    <li><a href="/tags/express/">express<sup>1</sup></a></li>
  
    <li><a href="/tags/fis/">fis<sup>1</sup></a></li>
  
    <li><a href="/tags/fisp/">fisp<sup>1</sup></a></li>
  
    <li><a href="/tags/grunt/">grunt<sup>1</sup></a></li>
  
    <li><a href="/tags/handleEvent/">handleEvent<sup>1</sup></a></li>
  
    <li><a href="/tags/html5/">html5<sup>3</sup></a></li>
  
    <li><a href="/tags/iframe/">iframe<sup>1</sup></a></li>
  
    <li><a href="/tags/iptables/">iptables<sup>1</sup></a></li>
  
    <li><a href="/tags/javascript/">javascript<sup>79</sup></a></li>
  
    <li><a href="/tags/linux/">linux<sup>4</sup></a></li>
  
    <li><a href="/tags/livereload/">livereload<sup>1</sup></a></li>
  
    <li><a href="/tags/memcached/">memcached<sup>1</sup></a></li>
  
    <li><a href="/tags/mixjs/">mixjs<sup>1</sup></a></li>
  
    <li><a href="/tags/mysql/">mysql<sup>2</sup></a></li>
  
    <li><a href="/tags/name/">name<sup>1</sup></a></li>
  
    <li><a href="/tags/nginx/">nginx<sup>2</sup></a></li>
  
    <li><a href="/tags/nodejs/">nodejs<sup>7</sup></a></li>
  
    <li><a href="/tags/php/">php<sup>19</sup></a></li>
  
    <li><a href="/tags/session/">session<sup>1</sup></a></li>
  
    <li><a href="/tags/storage/">storage<sup>1</sup></a></li>
  
    <li><a href="/tags/svn/">svn<sup>1</sup></a></li>
  
    <li><a href="/tags/this/">this<sup>1</sup></a></li>
  
    <li><a href="/tags/ueditor/">ueditor<sup>1</sup></a></li>
  
    <li><a href="/tags/uglifyjs/">uglifyjs<sup>1</sup></a></li>
  
    <li><a href="/tags/webbench/">webbench<sup>1</sup></a></li>
  
    <li><a href="/tags/websocket/">websocket<sup>1</sup></a></li>
  
    <li><a href="/tags/web前端开发/">web前端开发<sup>5</sup></a></li>
  
    <li><a href="/tags/windows7技巧/">windows7技巧<sup>1</sup></a></li>
  
    <li><a href="/tags/wordpress/">wordpress<sup>3</sup></a></li>
  
    <li><a href="/tags/xss/">xss<sup>3</sup></a></li>
  
    <li><a href="/tags/严格模式/">严格模式<sup>1</sup></a></li>
  
    <li><a href="/tags/位运算/">位运算<sup>1</sup></a></li>
  
    <li><a href="/tags/作用域/">作用域<sup>3</sup></a></li>
  
    <li><a href="/tags/前端优化/">前端优化<sup>1</sup></a></li>
  
    <li><a href="/tags/前端工具/">前端工具<sup>5</sup></a></li>
  
    <li><a href="/tags/加速器/">加速器<sup>1</sup></a></li>
  
    <li><a href="/tags/压力测试/">压力测试<sup>1</sup></a></li>
  
    <li><a href="/tags/右键/">右键<sup>1</sup></a></li>
  
    <li><a href="/tags/安全/">安全<sup>1</sup></a></li>
  
    <li><a href="/tags/性能/">性能<sup>3</sup></a></li>
  
    <li><a href="/tags/我也八卦/">我也八卦<sup>1</sup></a></li>
  
    <li><a href="/tags/执行环境/">执行环境<sup>1</sup></a></li>
  
    <li><a href="/tags/技巧/">技巧<sup>1</sup></a></li>
  
    <li><a href="/tags/播放器/">播放器<sup>1</sup></a></li>
  
    <li><a href="/tags/数组/">数组<sup>1</sup></a></li>
  
    <li><a href="/tags/标签/">标签<sup>1</sup></a></li>
  
    <li><a href="/tags/模块化/">模块化<sup>2</sup></a></li>
  
    <li><a href="/tags/算法/">算法<sup>1</sup></a></li>
  
    <li><a href="/tags/网络技术/">网络技术<sup>73</sup></a></li>
  
    <li><a href="/tags/虚拟主机/">虚拟主机<sup>1</sup></a></li>
  
    <li><a href="/tags/解耦/">解耦<sup>1</sup></a></li>
  
    <li><a href="/tags/语法限制/">语法限制<sup>1</sup></a></li>
  
    <li><a href="/tags/跨域/">跨域<sup>3</sup></a></li>
  
    <li><a href="/tags/路径/">路径<sup>1</sup></a></li>
  
    <li><a href="/tags/软件心得/">软件心得<sup>3</sup></a></li>
  
  </ul>
</div>



  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2013 三水清
  
</div>
<div class="clearfix"></div></footer>
  <script src="http://libs.baidu.com/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


    
        <script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=6635976" ></script>
        <script type="text/javascript" id="bdshell_js"></script>
        <script type="text/javascript">
        document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000);
        </script>
    
    



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>




    <script type="text/javascript">
    var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F1c76f5cc8274a56106b13b9c9b1fb046' type='text/javascript'%3E%3C/script%3E"));
    </script>


</body>
</html>