<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 3 页 - 归档：2011 - 三水清</title>
  <meta name="author" content="三水清">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="三水清"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="atom.xml" title="三水清" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">三水清</a></h1>
  <h2><a href="/">专注前端开发,分享Javascript/CSS/PHP等Web前端开发技巧</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/about">关于</a></li>
    
      <li><a href="https://github.com/ksky521">Github</a></li>
    
      <li><a href="http://weibo.com/sanshuiqing">新浪微博</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title">2011</h2>


  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
      
      
  
    <h1 class="title"><a href="/2011/08/15/javascript的词法作用域/">javascript的词法作用域</a></h1>
  

      <time datetime="2011-08-15T08:35:22.000Z"><a href="/2011/08/15/javascript的词法作用域/">2011年8月15日</a></time>
    </header>
    <div class="entry">
      
        <p>大家应该写过下面类似的代码吧，其实这里我想要表达的是有时候一个方法定义的地方和使用的地方会相隔十万八千里，那方法执行时，它能访问哪些变量，不能访问哪些变量，这个怎么判断呢？这个就是我们这次需要分析的问题——<strong>词法作用域</strong></p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">var</span> classA = <span class="keyword">function</span>(){
    <span class="keyword">this</span>.prop1 = <span class="number">1</span>;
}
classA.prototype.func1 = <span class="keyword">function</span>(){
    <span class="keyword">var</span> that = <span class="keyword">this</span>,
        var1 = <span class="number">2</span>;

    <span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span>{</span>
        <span class="keyword">return</span> <span class="keyword">function</span>(){
            alert(var1);
            alert(<span class="keyword">this</span>.prop1);
        }.apply(that);
    };
    a();
}
<span class="keyword">var</span> objA = <span class="keyword">new</span> ClassA();
objA.func1();
</pre></td></tr></table></figure>

<p><strong>词法作用域</strong>：变量的作用域是在定义时决定而不是执行时决定，也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。 with和eval除外，所以只能说JS的作用域机制非常接近词法作用域（Lexical scope）。</p>
<p>下面通过几个小小的案例，开始深入的了解对理解词法作用域和<strong>闭包</strong>必不可少的，JS执行时底层的一些概念和理论知识。</p>
<h2>经典案列重现</h2>
<h4>1、经典案例一</h4>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">/*全局（window）域下的一段代码*/</span>
<span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">(i)</span> {</span>
    <span class="keyword">var</span> i;
    alert(i);
};
a(<span class="number">10</span>);
</pre></td></tr></table></figure>

<p>疑问：上面的代码会输出什么呢？<br>答案：没错，就是弹出10。具体执行过程应该是这样的</p>
<blockquote>
<p>a 函数有一个形参 i，调用 a 函数时传入实参 10，形参 i=10<br>接着定义一个同名的局部变量 i，未赋值<br>alert 输出 10</p>
</blockquote>
<p>思考：局部变量 i 和形参 i 是同一个存储空间吗？</p>
<h4>2、经典案例二</h4>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">/*全局（window）域下的一段代码*/</span>
<span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">(i)</span> {</span>
    alert(i);
    alert(arguments[<span class="number">0</span>]); <span class="comment">//arguments[0]应该就是形参 i</span>
    <span class="keyword">var</span> i = <span class="number">2</span>;
    alert(i);
    alert(arguments[<span class="number">0</span>]);
};
a(<span class="number">10</span>);
</pre></td></tr></table></figure>

<p>疑问：上面的代码又会输出什么呢？（（ 10,10,2,10 || 10,10,2,2 ））<br>答案：在FireBug中的运行结果是第二个10,10,2,2，猜对了… ，下面简单说一下具体执行过程<br>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2011/08/15/javascript的词法作用域/#more" class="more-link">全文</a>
          </div>
        
        
      
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
      
      
  
    <h1 class="title"><a href="/2011/08/11/javascript变量类型/">javascript变量类型</a></h1>
  

      <time datetime="2011-08-11T12:51:09.000Z"><a href="/2011/08/11/javascript变量类型/">2011年8月11日</a></time>
    </header>
    <div class="entry">
      
        <p>javascript的<strong>变量类型</strong>真的很要人纠结，即使你是很有经验的js工程师，你也很难说清楚js的类型和分类。<br>最近在讲javascript入门指南的时候，有人提出数组为什么不是基本类型，我通过演示<code>typeof []</code>的结果来说明，数组是对象类型派生出来的，而不是六种基本类型。<br>其实要理解javascript的变量类型很简单，就是我们要找到一个划分的标准。</p>
<h2>javascript变量类型分类</h2>
<p>在很多书中都提到了javascript的变量类型，每本书都有不同的划分标准，如果按照typeof和instanceof的返回值来区分，可以把javascript的变量类型分为两套类型系统：基本类型和对象类型衍生出来的对象类型系统。<br>基本类型包括：undefined，number，boolean，string，object，function，他们之前通过typeof的返回值来区分。<br>第二套对象类型系统是由第一套系统衍生发展而来的，例如前面提到的Array，还有Null，Number，Boolean等等，对象类型可以通过<strong>instanceof</strong>来判断。<br>那么对象类型中的Number和基本类型中的number又是什么关系呢？他们又是什么区别呢？<br>答案就是，他们是映射关系，即下例：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> a = <span class="keyword">new</span> Number(<span class="number">123</span>);
console.log(a.valueOf()===<span class="number">123</span>);<span class="comment">//true</span>
<span class="keyword">var</span> b = <span class="keyword">new</span> String(<span class="number">123</span>);
console.log(b.valueOf()===<span class="number">123</span>);<span class="comment">//false</span>
console.log(b.valueOf()===<span class="string">'123'</span>);<span class="comment">//true</span>
</pre></td></tr></table></figure>

<p>obj.valueOf()返回的是该对象的原始值。</p>
<h2>值类型和引用类型</h2>
<p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2011/08/11/javascript变量类型/#more" class="more-link">全文</a>
          </div>
        
        
      
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
      
      
  
    <h1 class="title"><a href="/2011/08/05/ie的fireevent方法/">IE的fireEvent方法</a></h1>
  

      <time datetime="2011-08-04T19:51:20.000Z"><a href="/2011/08/05/ie的fireevent方法/">2011年8月5日</a></time>
    </header>
    <div class="entry">
      
        <p>在IE中提供了一个<strong>fireEvent</strong>方法，顾名思义就是触发某个事件发生的意思。刚开始我以为是会跟平时使用<code>onclick()</code>一样，没想到最近在写javascript入门ppt的时候发现了，原来自己太自以为是了！看来还有很多javascript的细节没有掌握好啊！</p>
<p>现在根据自己的总结详细的记录下fireEvent方法的使用。fireEvent是IE提供的一种方法，msdn文档地址：<a href="http://msdn.microsoft.com/en-us/library/ms536423(v=vs.85).aspx" target="_blank">http://msdn.microsoft.com/en-us/library/ms536423(v=vs.85).aspx</a></p>
<h3>onclick()</h3>
<p>我们先看第一段实例代码：</p>
<pre lang="html">

*   i am one;
*   i am two;
*   i am three;
<button onclick='document.getElementById("id1").onclick();'>click me!</button>
</pre>
这段代码中我们没有个id1的li添加onclick事件，点击button，会报错，提示“对象不支持此属性或方法”。由此可见，DOM.onclick()需要添加onclick事件之后才能使用。

假如我们把以上的代码修改为：
<pre lang="html">

*   i am one;
*   i am two;
*   i am three;
<button onclick='document.getElementById("id1").onclick();'>click me!</button>
</pre>

      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2011/08/05/ie的fireevent方法/#more" class="more-link">全文</a>
          </div>
        
        
      
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
      
      
  
    <h1 class="title"><a href="/2011/08/03/javascript匿名函数/">javascript匿名函数</a></h1>
  

      <time datetime="2011-08-02T21:47:48.000Z"><a href="/2011/08/03/javascript匿名函数/">2011年8月3日</a></time>
    </header>
    <div class="entry">
      
        <p>今天在整理javascript入门培训的PPT时，提到了<strong>匿名函数</strong>，所以拿来分享下心得。</p>
<h3>匿名函数的写法</h3>
<p>顾名思义，就是没有名字的函数（⊙﹏⊙b汗）。匿名函数通常用于javascript作用域的控制，可以有效的避免对全局变量的污染。常见的匿名函数有下面四种写法，欢迎补充：</p>
<h4>匿名函数写法一</h4>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>
(<span class="keyword">function</span>(){
	<span class="comment">//do something</span>
})();
</pre></td></tr></table></figure>

<h4>匿名函数写法二</h4>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>
!<span class="keyword">function</span>(){
	<span class="comment">//do something</span>
}();
</pre></td></tr></table></figure>

<p>上面!还可以写成+，!!等多种方式。<br>上面两种方法是我常用的，下面两种方法是google上找的，我没用过（好吧，我out啦）。</p>
<h4>匿名函数写法三</h4>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>
(<span class="keyword">function</span>(){
	<span class="comment">//do something</span>
}());
</pre></td></tr></table></figure>

<h4>匿名函数写法四</h4>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>
<span class="keyword">void</span> <span class="keyword">function</span>(){
	<span class="comment">//do something</span>
}();
</pre></td></tr></table></figure>

<p>刚才微博上@朴灵 提出来：写法三比较安全，正如网友@Rain的留言，匿名函数上面的写法都存在前后文;问题，所以需要注意的是匿名函数在压缩工具打包压缩后会出现上下文错误合并()的问题，例如第一种写法，如果下面的代码，未压缩之前是正常的，压缩后就不正常了，所以要严格上下文的;问题，而第三种就不会出现类似问题：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>
<span class="keyword">var</span> a = <span class="keyword">function</span>(){}
(<span class="keyword">function</span>(){
	alert(<span class="number">1</span>);
})();
</pre></td></tr></table></figure>

<p>上例中就出现了错误，这就是因为a函数会把他后面的匿名函数作为参数传入a中，这也就解释了为什么有人习惯在匿名函数之前添加;了，就是为了防止上文没有严格遵循javascript语法，漏掉;的问题。<br>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2011/08/03/javascript匿名函数/#more" class="more-link">全文</a>
          </div>
        
        
      
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
      
      
  
    <h1 class="title"><a href="/2011/07/20/ie6中a标签location-href失效解决方法/">IE6中a标签location.href失效解决方法</a></h1>
  

      <time datetime="2011-07-19T23:00:51.000Z"><a href="/2011/07/20/ie6中a标签location-href失效解决方法/">2011年7月20日</a></time>
    </header>
    <div class="entry">
      
        <p>今天遇见IE6一个<strong>location.href</strong>的bug，具体情况是这样的，IE6下，在a标签中，将href写成<code>javascript:;``javascript:void(0);</code>，并且给这个标签绑定onclick事件，点击后，执行location.href实现页面跳转，例如下面的代码：</p>
<figure class="highlight lang-html"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>[点击跳转](javascitp:;)
</pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight lang-html"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
[点击跳转](javascitp:void(0);)
</pre></td></tr></table></figure>

<p>toURL函数的代码如下所示：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">toURL</span><span class="params">()</span>{</span>
	location.href = <span class="string">"http://js8.in"</span>;
}
</pre></td></tr></table></figure>

<p>这样在非IE6浏览器下都可以使用，但是在IE6下就是跳转不了，而且不报错，在location.href之后的代码，例如（alert(1);）也是执行的。</p>
<h3>IE6下location.href失效解决的方法</h3>
<p>解决IE6中a标签中location.href失效的方式就是a标签中的href不用使用<code>javascript:;</code>或<code>javascript:void(0);</code>。具体原因还不清楚，不过我们可以使用href=“#”来代替。<br>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2011/07/20/ie6中a标签location-href失效解决方法/#more" class="more-link">全文</a>
          </div>
        
        
      
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
      
      
  
    <h1 class="title"><a href="/2011/07/13/javascript事件：获取事件对象getevent函数/">javascript事件：获取事件对象getEvent函数</a></h1>
  

      <time datetime="2011-07-12T20:11:59.000Z"><a href="/2011/07/13/javascript事件：获取事件对象getevent函数/">2011年7月13日</a></time>
    </header>
    <div class="entry">
      
        <p>在<strong>javascript</strong>开发中我们会经常获取页面中的事件对象，然后来处理这些事件，例如下面的<strong>getEvent</strong>函数就是获取javascript下的页面事件对象。</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>
<span class="function"><span class="keyword">function</span> <span class="title">getEvent</span><span class="params">(event)</span>{</span>
	<span class="keyword">return</span> event || window.event;
}
</pre></td></tr></table></figure>

<p>我们使用getEvent的时候可以这样调用。</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>
<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(event)</span>{</span>
	<span class="keyword">var</span> evt = getEvent(event);
	alert(evt);
}
</pre></td></tr></table></figure>

<p>并且把foo函数绑定到一个onclick事件上。<br>但是常用的是foo函数不会有参数，或者第一个参数没有传入，我们可以通过<code>arguments[0]</code>来获取第一个参数。<br>在IE中event是一个全局变量，即<code>window.event</code>，而在Firefox等浏览器，事件会作为第一个参数传入foo函数，所以getEvent可以改为：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>
<span class="function"><span class="keyword">function</span> <span class="title">getEvent</span><span class="params">(event)</span>{</span>
	<span class="keyword">return</span> arguments[<span class="number">0</span>] || window.event;
}
</pre></td></tr></table></figure>

<p>这时在一些版本的浏览器，例如Firefox 中会出现获取不到event对象的问题，其实我们可以看成事件的触发是下面的方式：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>
<span class="function"><span class="keyword">function</span> <span class="title">onclick</span><span class="params">(event)</span> {</span>
    foo();
}
</pre></td></tr></table></figure>

<p>这样，第一个函数是onclick，即event会默认作为第一个参数传入，而foo函数没有将event作为参数传入，这样严重限制了getEvent的灵活性，所以我们需要修改下<strong>getEvent</strong>函数。<br>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2011/07/13/javascript事件：获取事件对象getevent函数/#more" class="more-link">全文</a>
          </div>
        
        
      
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
      
      
  
    <h1 class="title"><a href="/2011/07/07/新浪微博jssdk操作指南/">新浪微博jsSDK操作指南</a></h1>
  

      <time datetime="2011-07-07T12:32:41.000Z"><a href="/2011/07/07/新浪微博jssdk操作指南/">2011年7月7日</a></time>
    </header>
    <div class="entry">
      
        <p><strong>新浪微博</strong>的开放平台提供了<strong>jsSDK</strong>的方法，但是很多人反映不会使用，这里最关键的一点是不会放跨域文件。<br>的确，我也承认开放平台的开发文档写的不是很详细，比如对于一些接口是使用REST的，要人云里雾里，而对于REST的介绍却很隐晦，我也是尝试了几次才找到的方法（例如删除微博接口）。<br>下面简单说说jsSDK的操作。</p>
<h3>放置跨域文件</h3>
<p>为了实现跨域请求api的接口，我们需要在自己的域名下放置一个xd.html的文件，这个文件可以理解成在你网站做代理的，通过它才可以请求道api.t.sina.com.cn的内容。感兴趣的童靴可以研究下这种跨域的实现方式，国内的人人、腾讯，国外的facebook都是这种跨域方式。</p>
<p>基本原理是通过html5的postMessage和window.name来实现跨域。其实如果进一步研究是完全可以不要这个跨域文件的！相信下一个版本的JSSDK不会出现跨域文件来误导大家。<br><strong>跨域文件</strong>放置要点</p>
<ol>
<li>放置来应用的同域名下，例如你的应用网址是js8.in，则你的xd.html文件就要放在js8.in域名下</li>
<li>不一定是根目录下，因为可以通过jsSDK中的<code>xdpath</code>来传入xd.html路径，默认是根目录，即js8.in/xd.html
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2011/07/07/新浪微博jssdk操作指南/#more" class="more-link">全文</a>
          </div>
        
        
      
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
      
      
  
    <h1 class="title"><a href="/2011/06/20/javascript继承的写法/">javascript继承的写法</a></h1>
  

      <time datetime="2011-06-19T20:38:21.000Z"><a href="/2011/06/20/javascript继承的写法/">2011年6月20日</a></time>
    </header>
    <div class="entry">
      
        <p>严格来说<strong>javascript</strong>是基于对象而不是面向对象的语言，因为javascript没有像java语言那么丰富的类、继承、封装，但是javascript是基于原型（prototype）的面向对象开发，是一种动态、弱类型、基于原型的语言。前几天看了阿里UED的《重温<strong>javascript继承</strong>机制》，今天重新看了，很有感触，特地转载了重要的部分，记录一下，下次有需要的时候还要重新看一下！的确是不错的一篇文章。</p>
<h3>继承的演变</h3>
<h4>1、采用new关键字生成实例</h4>
<p>处理表单验证这样简单功能脚本语言显然是不需要”继承”机制的，然而如果Javascript里面都是对象，就需要有一种办法来把所有对象联系起来。最后，Brendan Eich还是设计了”继承”。只是，他并没有引入”类”（class）的概念，因为一旦有了”类”，Javascript就是一种完整的面向对象编程语言了，<br>这好像有点太正式了，与设计初衷也远了，同时增加了初学者的入门难度。<br>参照到C++和Java语言都使用new命令来生成实例：</p>
<p>C++这样写：</p>
<blockquote>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
&gt; ClassName *object = <span class="keyword">new</span> ClassName(param);
</pre></td></tr></table></figure>

</blockquote>
<p>Java这样写：</p>
<blockquote>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
&gt; Foo foo = <span class="keyword">new</span> Foo();
</pre></td></tr></table></figure>

</blockquote>
<p>那么，也可以把new命令引入了Javascript，用来从原型对象生成一个实例对象。但是，<strong>Javascript</strong>中没有”类”的话，怎样表示原型对象呢？<br>依然是参照C++和Java使用new命令时，都会调用”类”的构造函数（constructor）。Brendan Eich简化了设计，在Javascript语言中，new命令后面跟的是构造函数，不再是类。<br>我们举个例子来说，现在有一个叫做WD构造函数，表示前端开发（web-developper）对象的原型。</p>
<blockquote>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>
&gt; <span class="function"><span class="keyword">function</span> <span class="title">WD</span><span class="params">(skill)</span>{</span>
&gt; 	<span class="keyword">this</span>.skill = skill;
&gt; }
</pre></td></tr></table></figure>

</blockquote>
<p>对这个构造函数使用new关键字，就会生成一个前端开发对象的实例。</p>
<blockquote>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>
&gt; <span class="keyword">var</span> WD1 = <span class="keyword">new</span> WD(<span class="string">'html'</span>);
&gt; console.log(WD1.skill); <span class="comment">// html</span>
</pre></td></tr></table></figure>

</blockquote>
<p>在构造函数中的this关键字，它其实代表的是新创建的实例对象。</p>
<h4>2、new 出来对象的缺陷</h4>
<p>采用new关键字，用构造函数生成实例对象无法共享属性和方法。<br>比如，在WD对象的构造函数中，设置一个实例对象的共有属性skill。</p>
<blockquote>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>
&gt; <span class="function"><span class="keyword">function</span> <span class="title">WD</span><span class="params">(skill)</span>{</span>
&gt; 	<span class="keyword">this</span>.skill = skill;
&gt; 	<span class="keyword">this</span>.sex = <span class="string">'男'</span>;
&gt; }
</pre></td></tr></table></figure>

</blockquote>
<p>然后，生成两个实例对象：</p>
<blockquote>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>
&gt; <span class="keyword">var</span> WD1 = <span class="keyword">new</span> WD(<span class="string">'html'</span>);
&gt; <span class="keyword">var</span> WD2 = <span class="keyword">new</span> WD(<span class="string">'css'</span>);
</pre></td></tr></table></figure>

</blockquote>
<p>这两个对象的skill属性是独立的，修改其中一个，不会影响到另一个。</p>
<blockquote>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>
&gt; WD1.skill= <span class="string">'Javascript'</span>;
&gt; console.log(WD2.skill);<span class="comment">//“css”，不受WD1的影响</span>
</pre></td></tr></table></figure>

</blockquote>
<p>每一个实例对象，都有自己的属性和方法的副本。这不仅无法做到数据共享，也是极大的资源浪费。</p>
<h4>3、引入prototype属性</h4>
<p>为了实现属性和方法的共享，Brendan Eich决定为构造函数设置一个prototype属性。<br>这个属性包含一个对象（以下简称”prototype对象”），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。<br>实例对象一旦创建，将自动引用prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。<br>还是以WD构造函数为例，现在用prototype属性进行改写：</p>
<blockquote>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>
&gt; <span class="function"><span class="keyword">function</span> <span class="title">WD</span><span class="params">(skill)</span>{</span>
&gt; 	<span class="keyword">this</span>.skill = skill;
&gt; }
&gt; 
&gt; WD.prototype = { sex : <span class="string">'男'</span> };
&gt; 
&gt; <span class="keyword">var</span> WD1 = <span class="keyword">new</span> WD(<span class="string">'html'</span>);
&gt; <span class="keyword">var</span> WD2 = <span class="keyword">new</span> WD(<span class="string">'css'</span>);
&gt; 
&gt; console.log(WD1.sex); <span class="comment">// 男</span>
&gt; console.log(WD2.sex); <span class="comment">// 男</span>
</pre></td></tr></table></figure>

</blockquote>
<p>现在，sex属性放在prototype对象里，是两个实例对象共享的。只要修改了prototype对象，就会同时影响到两个实例对象。</p>
<blockquote>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>
&gt; WD.prototype.sex = <span class="string">'女'</span>;
&gt; console.log(WD1.sex); <span class="comment">//女</span>
&gt; console.log(WD2.sex); <span class="comment">// 女</span>
</pre></td></tr></table></figure>

</blockquote>
<p>由于所有的实例对象共享同一个prototype对象，那么从外界看起来，prototype对象就好像是实例对象的原型，而实例对象则好像”继承”了prototype对象一样。这就是Javascript继承机制的设计思想。</p>
<h3>三、构造函数如何实现继承</h3>
<p>现在有一个”MED”对象的构造函数（MED:Marketing Experience Design,营销体验设计）</p>
<blockquote>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>
&gt; <span class="function"><span class="keyword">function</span> <span class="title">MED</span><span class="params">()</span>{</span>
&gt; 	<span class="keyword">this</span>.aim = <span class="string">"营销体验设计"</span>;
&gt; }
</pre></td></tr></table></figure>

</blockquote>
<p>依然是”WD”对象的构造函数，</p>
<blockquote>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>
&gt; <span class="function"><span class="keyword">function</span> <span class="title">WD</span><span class="params">(skill,sex)</span>{</span>
&gt; 	<span class="keyword">this</span>.skill = skill;
&gt; 	<span class="keyword">this</span>.sex = sex;
&gt; }
</pre></td></tr></table></figure>

</blockquote>
<p>怎样才能使”WD”继承”MED”呢？<br>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2011/06/20/javascript继承的写法/#more" class="more-link">全文</a>
          </div>
        
        
      
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
      
      
  
    <h1 class="title"><a href="/2011/06/13/json_encode数组出现unicode-uxxxx的解决方案/">json_encode数组出现unicode \uxxxx的解决方案</a></h1>
  

      <time datetime="2011-06-13T15:16:15.000Z"><a href="/2011/06/13/json_encode数组出现unicode-uxxxx的解决方案/">2011年6月13日</a></time>
    </header>
    <div class="entry">
      
        <p>端午和上个周末做的微博应用<a href="//dali.sinaapp.com">送大礼</a>中设计到ajax返回json的数据格式中，我没有完全使用PHP默认的<strong>json_encode</strong>来编码，因为这样编码出来的是unicode编码的，也就是\u的编码，虽然unicode编码可以在不同的页面中编码不会出现乱码问题。但是一个汉字编码成unicode会变成\u+4个字符，这样在字符长度上要比汉字多。</p>
<p>因为我的php文件和html声明中都是使用的UTF-8，不会出现编码乱码问题，所以就放弃了直接使用json_encode的方法，而是把汉字先<strong>urlencode</strong>然后再使用json_encode，json_encode之后再次使用urldecode来解码，这样编码出来的json数组中的汉字就不会出现unicode编码了~<br>代码如下</p>
<figure class="highlight lang-php"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">//默认为：{"test":"\u6211\u662f\u6d4b\u8bd5"}</span>
<span class="variable">$array</span> = <span class="keyword">array</span>(
	<span class="string">'test'</span>=&gt;urlencode(<span class="string">"我是测试"</span>)
);
<span class="variable">$array</span> = json_encode(<span class="variable">$array</span>);
<span class="keyword">echo</span> urldecode(<span class="variable">$array</span>);
<span class="comment">//{"test":"我是测试"}</span>
</pre></td></tr></table></figure>

<p>此举主要是为了节省传输字符数，因为我的<a href="//dali.sinaapp.com">送大礼</a>默认会引入几百个好友信息，对于数据的流量还是比较大的~所以采用汉字传输要比unicode字符编码传输要节省带宽~而且处理好了页面编码问题，不会出现乱码现象。</p>
<h3>json_encode出null的问题</h3>
<p>如果文档编码或者字符串编码（例如UTF-8抓取了一个GBK页面）为非UTF-8，就会出现json_encode编码失败的问题，变现为输出汉字为null。<br>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2011/06/13/json_encode数组出现unicode-uxxxx的解决方案/#more" class="more-link">全文</a>
          </div>
        
        
      
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
      
      
  
    <h1 class="title"><a href="/2011/05/20/nodelist集合跟array数组的区别/">NodeList集合跟Array数组的区别</a></h1>
  

      <time datetime="2011-05-20T09:27:16.000Z"><a href="/2011/05/20/nodelist集合跟array数组的区别/">2011年5月20日</a></time>
    </header>
    <div class="entry">
      
        <p>首先来看看什么是<strong>NodeList</strong>，NodeList跟arguments都不是普通的数组，他们有数组的一些基本属性但是又不完全是数组。下面是在<a href="https://developer.mozilla.org/En/DOM/NodeList" target="_blank">Mozilla</a>上面找到的定义：</p>
<blockquote>
<p>This is a commonly used type which is a collection of nodes returned by getElementsByTagName, getElementsByTagNameNS, and Node.childNodes. The list is live, so changes to it internally or externally will cause the items they reference to be updated as well. Unlike NamedNodeMap, NodeList maintains a particular order (document order). The nodes in a NodeList are indexed starting with zero, similarly to JavaScript arrays, but a NodeList is not an array.<br>由字面意思来看<strong>NodeList</strong>是DOM操作（getElementsByTagName等）取出来的集合，是集合而不是普通的数组，但是他们有数组的一些属性，例如length、下标索引，但是他们也有自己的属性，例如item，另外NodeList最大的特点就是时效性（live）。</p>
</blockquote>
<h3>NodeList的时效性</h3>
<p>我们来看下面的代码：</p>
<figure class="highlight lang-html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>

*   index0
*   index1
*   index2
*   index3
*   index4
</pre></td></tr></table></figure>

<p>javascript代码如下：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>
<span class="keyword">var</span> myUl = document.getElementById(<span class="string">'nodelist'</span>);
<span class="keyword">var</span> lis = myUl.getElementsByTagName(<span class="string">'li'</span>);
</pre></td></tr></table></figure>

<p>lis是一个NodeList集合，具有时效性，所谓的时效性就是我们在修改li的同时，会反映到lis上来，这与array是不同的，例如我们把第一个li插入到ul的底部，那么lis也会发生相应的变化：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>
<span class="comment">//把第一个li插入的ul的底部</span>
myUl.appendChild(myUl.getElementsByTagName(<span class="string">'li'</span>).item(<span class="number">0</span>));
console.log(lis[<span class="number">0</span>]);<span class="comment">//输出的是原来ul的第二个li</span>
</pre></td></tr></table></figure>

<p>所以我们应该在写代码的时候注意<strong>NodeList</strong>的时效性，不然就会犯一些错误，
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2011/05/20/nodelist集合跟array数组的区别/#more" class="more-link">全文</a>
          </div>
        
        
      
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  

  
</div></div>
    <aside id="sidebar" class="alignright">
  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/乱七八糟/">乱七八糟</a><small>30</small></li>
  
    <li><a href="/categories/前端开发/">前端开发</a><small>116</small></li>
  
    <li><a href="/categories/后端运维/">后端运维</a><small>27</small></li>
  
    <li><a href="/categories/王婆卖瓜/">王婆卖瓜</a><small>4</small></li>
  
    <li><a href="/categories/读书笔记/">读书笔记</a><small>5</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签</h3>
  <ul class="entry clearfix">
  
    <li><a href="/tags/DOM/">DOM<sup>2</sup></a></li>
  
    <li><a href="/tags/IE/">IE<sup>1</sup></a></li>
  
    <li><a href="/tags/IE6/">IE6<sup>2</sup></a></li>
  
    <li><a href="/tags/PPT/">PPT<sup>3</sup></a></li>
  
    <li><a href="/tags/VPS/">VPS<sup>1</sup></a></li>
  
    <li><a href="/tags/ajax/">ajax<sup>5</sup></a></li>
  
    <li><a href="/tags/apache/">apache<sup>1</sup></a></li>
  
    <li><a href="/tags/audio/">audio<sup>2</sup></a></li>
  
    <li><a href="/tags/a标签/">a标签<sup>1</sup></a></li>
  
    <li><a href="/tags/canvas/">canvas<sup>1</sup></a></li>
  
    <li><a href="/tags/chrome/">chrome<sup>3</sup></a></li>
  
    <li><a href="/tags/css/">css<sup>15</sup></a></li>
  
    <li><a href="/tags/eAccelerator/">eAccelerator<sup>1</sup></a></li>
  
    <li><a href="/tags/ecmascript/">ecmascript<sup>3</sup></a></li>
  
    <li><a href="/tags/escape/">escape<sup>1</sup></a></li>
  
    <li><a href="/tags/event/">event<sup>1</sup></a></li>
  
    <li><a href="/tags/express/">express<sup>1</sup></a></li>
  
    <li><a href="/tags/grunt/">grunt<sup>1</sup></a></li>
  
    <li><a href="/tags/handleEvent/">handleEvent<sup>1</sup></a></li>
  
    <li><a href="/tags/html5/">html5<sup>3</sup></a></li>
  
    <li><a href="/tags/iframe/">iframe<sup>1</sup></a></li>
  
    <li><a href="/tags/iptables/">iptables<sup>1</sup></a></li>
  
    <li><a href="/tags/javascript/">javascript<sup>79</sup></a></li>
  
    <li><a href="/tags/linux/">linux<sup>4</sup></a></li>
  
    <li><a href="/tags/livereload/">livereload<sup>1</sup></a></li>
  
    <li><a href="/tags/memcached/">memcached<sup>1</sup></a></li>
  
    <li><a href="/tags/mixjs/">mixjs<sup>1</sup></a></li>
  
    <li><a href="/tags/mysql/">mysql<sup>2</sup></a></li>
  
    <li><a href="/tags/name/">name<sup>1</sup></a></li>
  
    <li><a href="/tags/nginx/">nginx<sup>2</sup></a></li>
  
    <li><a href="/tags/nodejs/">nodejs<sup>7</sup></a></li>
  
    <li><a href="/tags/php/">php<sup>19</sup></a></li>
  
    <li><a href="/tags/session/">session<sup>1</sup></a></li>
  
    <li><a href="/tags/storage/">storage<sup>1</sup></a></li>
  
    <li><a href="/tags/svn/">svn<sup>1</sup></a></li>
  
    <li><a href="/tags/this/">this<sup>1</sup></a></li>
  
    <li><a href="/tags/ueditor/">ueditor<sup>1</sup></a></li>
  
    <li><a href="/tags/uglifyjs/">uglifyjs<sup>1</sup></a></li>
  
    <li><a href="/tags/webbench/">webbench<sup>1</sup></a></li>
  
    <li><a href="/tags/websocket/">websocket<sup>1</sup></a></li>
  
    <li><a href="/tags/web前端开发/">web前端开发<sup>5</sup></a></li>
  
    <li><a href="/tags/windows7技巧/">windows7技巧<sup>1</sup></a></li>
  
    <li><a href="/tags/wordpress/">wordpress<sup>3</sup></a></li>
  
    <li><a href="/tags/xss/">xss<sup>3</sup></a></li>
  
    <li><a href="/tags/严格模式/">严格模式<sup>1</sup></a></li>
  
    <li><a href="/tags/位运算/">位运算<sup>1</sup></a></li>
  
    <li><a href="/tags/作用域/">作用域<sup>3</sup></a></li>
  
    <li><a href="/tags/前端优化/">前端优化<sup>1</sup></a></li>
  
    <li><a href="/tags/前端工具/">前端工具<sup>4</sup></a></li>
  
    <li><a href="/tags/加速器/">加速器<sup>1</sup></a></li>
  
    <li><a href="/tags/压力测试/">压力测试<sup>1</sup></a></li>
  
    <li><a href="/tags/右键/">右键<sup>1</sup></a></li>
  
    <li><a href="/tags/安全/">安全<sup>1</sup></a></li>
  
    <li><a href="/tags/性能/">性能<sup>3</sup></a></li>
  
    <li><a href="/tags/我也八卦/">我也八卦<sup>1</sup></a></li>
  
    <li><a href="/tags/执行环境/">执行环境<sup>1</sup></a></li>
  
    <li><a href="/tags/技巧/">技巧<sup>1</sup></a></li>
  
    <li><a href="/tags/播放器/">播放器<sup>1</sup></a></li>
  
    <li><a href="/tags/数组/">数组<sup>1</sup></a></li>
  
    <li><a href="/tags/标签/">标签<sup>1</sup></a></li>
  
    <li><a href="/tags/模块化/">模块化<sup>2</sup></a></li>
  
    <li><a href="/tags/算法/">算法<sup>1</sup></a></li>
  
    <li><a href="/tags/网络技术/">网络技术<sup>73</sup></a></li>
  
    <li><a href="/tags/虚拟主机/">虚拟主机<sup>1</sup></a></li>
  
    <li><a href="/tags/解耦/">解耦<sup>1</sup></a></li>
  
    <li><a href="/tags/语法限制/">语法限制<sup>1</sup></a></li>
  
    <li><a href="/tags/跨域/">跨域<sup>3</sup></a></li>
  
    <li><a href="/tags/路径/">路径<sup>1</sup></a></li>
  
    <li><a href="/tags/软件心得/">软件心得<sup>3</sup></a></li>
  
  </ul>
</div>



  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2013 三水清
  
</div>
<div class="clearfix"></div></footer>
  <script src="http://libs.baidu.com/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


    
        <script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=6635976" ></script>
        <script type="text/javascript" id="bdshell_js"></script>
        <script type="text/javascript">
        document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000);
        </script>
    
    



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>




    <script type="text/javascript">
    var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F1c76f5cc8274a56106b13b9c9b1fb046' type='text/javascript'%3E%3C/script%3E"));
    </script>


</body>
</html>