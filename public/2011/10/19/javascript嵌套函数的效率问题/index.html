<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>javascript嵌套函数的效率问题 - 三水清</title>
  <meta name="author" content="三水清">
  
  <meta name="description" content="javascript自诞生以来就是一门受争议的编程语言，很多人也对javascript的语法表示不解，例如javascript嵌套函数。本文来自Nettuts+的一篇教程，详细的介绍了javascript中嵌套函数效率问题，从小处说起，一直说到匿名函数、继承，感觉不错。
嵌套函数效率
很多jser喜欢在javascript代码中使用嵌套函数，例如下面的例子就是一个典型的嵌套函数：
1
2
3
4
5
6
7
8
9
function foo(a, b) {
    function bar() {
        return a + b;
    }

    return bar();
}

foo(1, 2);


上面的代码中foo()中嵌入了bar()，当foo()运行的时候，就会调用bar()。javascript引擎不会创建bar()函数，直到外部引用了foo()，随着foo()的运行结束，bar()也会销毁。
当多次运行foo的时候，javascript引擎就要在每次的运行foo时创建bar函数，而每次foo结束就要销毁bar函数，这是一个很费劲的工作。
那么为什么我们不把bar函数拿出来，做为一个独立的函数，它在foo外部只被创建一次，而不是多次，这样就大大的提高了代码效率。例如下面的代码：
1
2
3
4
5
6
7
8
9
function foo(a, b) {
    return bar(a, b);
}

function bar(a, b) {
    return a + b;
}

foo(1, 2);


当然这样做可能随着程序的复杂性，可能存在命名冲突的危险，所以jser需要在这方面权衡，或者采用命名空间来解决这个方式。下面是在jsperf中做的关于上面两个函数大量运行的速度测试http://jsperf.com/nested-named-functions。不同的浏览器测试的结果不同，但是总体来看，两个独立的函数要比相互嵌套的javascript函数效率提高10%~90%。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="javascript嵌套函数的效率问题"/>
  <meta property="og:site_name" content="三水清"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="atom.xml" title="三水清" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">三水清</a></h1>
  <h2><a href="/">专注前端开发,分享Javascript/CSS/PHP等Web前端开发技巧</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/about">关于</a></li>
    
      <li><a href="https://github.com/ksky521">Github</a></li>
    
      <li><a href="http://weibo.com/sanshuiqing">新浪微博</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon icon-black"></div>
      
      
  
    <h1 class="title">javascript嵌套函数的效率问题</h1>
  

      <time datetime="2011-10-19T13:27:00.000Z"><a href="/2011/10/19/javascript嵌套函数的效率问题/">2011年10月19日</a></time>
    </header>
    <div class="entry">
      
        <p>javascript自诞生以来就是一门受争议的编程语言，很多人也对javascript的语法表示不解，例如javascript嵌套函数。本文来自Nettuts+的一篇教程，详细的介绍了<strong>javascript</strong>中嵌套函数效率问题，从小处说起，一直说到匿名函数、继承，感觉不错。</p>
<h2>嵌套函数效率</h2>
<p>很多jser喜欢在javascript代码中使用嵌套函数，例如下面的例子就是一个典型的嵌套函数：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(a, b)</span> {</span>
    <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> a + b;
    }

    <span class="keyword">return</span> bar();
}

foo(<span class="number">1</span>, <span class="number">2</span>);
</pre></td></tr></table></figure>

<p>上面的代码中<code>foo()</code>中嵌入了<code>bar()</code>，当<code>foo()</code>运行的时候，就会调用<code>bar()</code>。javascript引擎不会创建<code>bar()</code>函数，直到外部引用了<code>foo()</code>，随着<code>foo()</code>的运行结束，<code>bar()</code>也会销毁。</p>
<p>当多次运行<code>foo</code>的时候，<strong>javascript引擎</strong>就要在每次的运行<code>foo</code>时创建<code>bar</code>函数，而每次<code>foo</code>结束就要销毁<code>bar</code>函数，这是一个很费劲的工作。</p>
<p>那么为什么我们不把<code>bar</code>函数拿出来，做为一个独立的函数，它在<code>foo</code>外部只被创建一次，而不是多次，这样就大大的提高了代码效率。例如下面的代码：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(a, b)</span> {</span>
    <span class="keyword">return</span> bar(a, b);
}

<span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">(a, b)</span> {</span>
    <span class="keyword">return</span> a + b;
}

foo(<span class="number">1</span>, <span class="number">2</span>);
</pre></td></tr></table></figure>

<p>当然这样做可能随着程序的复杂性，可能存在命名冲突的危险，所以jser需要在这方面权衡，或者采用命名空间来解决这个方式。下面是在jsperf中做的关于上面两个函数大量运行的速度测试<a href="http://jsperf.com/nested-named-functions" target="_blank"><a href="http://jsperf.com/nested-named-functions">http://jsperf.com/nested-named-functions</a></a>。不同的浏览器测试的结果不同，但是总体来看，两个独立的函数要比相互嵌套的javascript函数效率提高10%~90%。<br><a id="more"></a></p>
<h2>匿名函数</h2>
<p>javascript开发中常用到匿名函数，例如事件处理函数、callback函数等，例如下面的事件处理函数：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>document.addEventListener(<span class="string">"click"</span>, <span class="keyword">function</span>(evt) {
    alert(<span class="string">"You clicked the page."</span>);
});
</pre></td></tr></table></figure>

<p>这里给document创建了一个事件监听，当每次页面点击之后会alert出来一条消息。跟嵌套函数一样，每次点击需要运行一次匿名函数，处理事件完成之后再销毁。</p>
<p>jQuery中的each方法也是一个<strong>匿名函数</strong>，例如下面的代码，选择出来所有的a元素，并且添加each方法来处理a元素：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>$(<span class="string">"a"</span>).each(<span class="keyword">function</span>(index) {
    <span class="keyword">this</span>.style.color = <span class="string">"red"</span>;
});
</pre></td></tr></table></figure>

<p>如果写成jQuery插件，可以下面的代码：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>$.fn.myPlugin = <span class="keyword">function</span>(options) {

    <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="keyword">function</span>() {
        <span class="keyword">var</span> $<span class="keyword">this</span> = $(<span class="keyword">this</span>);

        <span class="function"><span class="keyword">function</span> <span class="title">changeColor</span><span class="params">()</span> {</span>
            $<span class="keyword">this</span>.css({color : options.color});
        }

        changeColor();
    });
};
</pre></td></tr></table></figure>

<p>javascript代码定义了一个名字为myPlugin的jQuery插件，插件中有一个嵌套函数changeColor，根据上面说的，上面的代码效率不如独立出来changeColor高，所以我们可以把changeColor拿到外部来，即下面的代码：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span><span class="params">($obj, color)</span> {</span>
    $obj.css({color : color});
}

$.fn.myPlugin = <span class="keyword">function</span>(options) {

    <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="keyword">function</span>() {
        <span class="keyword">var</span> $<span class="keyword">this</span> = $(<span class="keyword">this</span>);

        changeColor($<span class="keyword">this</span>, options.color);
    });
};
</pre></td></tr></table></figure>

<p>经过修改过的jQuery插件在效率上提高了15%左右，大家可以通过<a href="http://jsperf.com/function-nesting-with-jquery-plugin" target="_blank">jsperf</a>来测试两个jQuery插件的效率。所以说嵌套的函数越多，调用的次数越多，则可以优化的地方也越多。</p>
<h2>javascript嵌套函数和函数构造</h2>
<p>我们在javascript类中长写下面的代码：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(firstName, lastName)</span> {</span>
    <span class="keyword">this</span>.firstName = firstName;
    <span class="keyword">this</span>.lastName = lastName;

    <span class="keyword">this</span>.getFullName = <span class="keyword">function</span>() {
        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;
    };
}

<span class="keyword">var</span> jeremy = <span class="keyword">new</span> Person(<span class="string">"Jeremy"</span>, <span class="string">"McPeak"</span>),
    jeffrey = <span class="keyword">new</span> Person(<span class="string">"Jeffrey"</span>, <span class="string">"Way"</span>);
</pre></td></tr></table></figure>

<p>这段代码定义了一个Person的类，其中包括了<code>getFullName</code>的方法，将firstName和lastName返回。<code>getFullName</code>的方法在每次创建不同的Person对象时会不同，所以<code>jeremy.getFullName === jeffrey.getFullName</code>返回的结果是<code>false</code>(<a href="http://jsfiddle.net/k9uRN/" target="_blank"><a href="http://jsfiddle.net/k9uRN/">http://jsfiddle.net/k9uRN/</a></a>).<br>具体分析见下面图，jeremy和jeffrey是不同的两个对象，他们的getFullName也是不同的。</p>
<p><a href="/uploads/2011/10/js_func_fig1-300x240.gif"><img src="/uploads/2011/10/js_func_fig1-300x240.gif" alt="jeremy和jeffrey" title="jeremy和jeffrey"></a></p>
<h3>使用prototype关键字</h3>
<p>在javascript中有<strong>prototype</strong>这个关键字，<code>prototype</code>的属性是实例化后的对象所共有的属性，所以上面的代码可以通过prototype改写成下面的方式：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(firstName, lastName)</span> {</span>
    <span class="keyword">this</span>.firstName = firstName;
    <span class="keyword">this</span>.lastName = lastName;
}

Person.prototype.getFullName = <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;
};

<span class="keyword">var</span> jeremy = <span class="keyword">new</span> Person(<span class="string">"Jeremy"</span>, <span class="string">"McPeak"</span>),
    jeffrey = <span class="keyword">new</span> Person(<span class="string">"Jeffrey"</span>, <span class="string">"Way"</span>);
</pre></td></tr></table></figure>

<p>这样<code>getFullName</code>的方法是定义在<code>Person.prototype</code>中的，为所有实例化的对象共有方法，所以jeremy和jeffrey的<code>getFullName</code>是相等的(<a href="http://jsfiddle.net/Pfkua/" target="_blank"><a href="http://jsfiddle.net/Pfkua/">http://jsfiddle.net/Pfkua/</a></a>)。他们之间的关系可以通过下面的图片来解释：</p>
<p><a href="/uploads/2011/10/js_func_fig2-300x240.gif"><img src="/uploads/2011/10/js_func_fig2-300x240.gif" alt="jeremy和jeffrey共有getFullName" title="jeremy和jeffrey"></a></p>
<p>通过<a href="http://jsperf.com/prototype-vs-non-prototype" target="_blank">jsPerf</a>的测试，我们可以看出来，第二种方法要比第一种方法在效率上面快了18%~96%。</p>
<h3>变量的私有化</h3>
<p>在函数内部的变量是私有的，外面是不可以访问到函数内部的变量的，但是函数内部可以访问到外部的变量。看下面的代码：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Foo</span><span class="params">(paramOne)</span> {</span>
    <span class="keyword">var</span> thisIsPrivate = paramOne;

    <span class="keyword">this</span>.bar = <span class="keyword">function</span>() {
        <span class="keyword">return</span> thisIsPrivate;
    };
}

<span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(<span class="string">"Hello, Privacy!"</span>);
alert(foo.bar()); <span class="comment">// alerts "Hello, Privacy!"</span>
</pre></td></tr></table></figure>

<p>代码中创建了一个构造函数<code>Foo();</code>，并且私有了一个变量<code>thisIsPrivate</code>，当运行<code>bar()</code>时，私有的<code>thisIsPrivate</code>会被返回。这样<code>thisIsPrivate</code>受到了保护，在<code>Foo()</code>之外是访问不到的.</p>
<p>这种方法也是很多javascript工程师所推荐的写法，但是跟上面的代码一样，每次实例化<code>Foo();</code>之时，会创建一个<code>bar</code>方法，这样看上去又是对资源的浪费，而且会影响效率。所以我们可以通过使用prototype的方法来实现：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Foo</span><span class="params">(paramOne)</span> {</span>
    <span class="keyword">this</span>._thisIsPrivate = paramOne;
}

Foo.prototype.bar = <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="keyword">this</span>._thisIsPrivate;
};

<span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(<span class="string">"Hello, Convention to Denote Privacy!"</span>);
alert(foo.bar()); <span class="comment">// alerts "Hello, Convention to Denote Privacy!"</span>
</pre></td></tr></table></figure>

<p>这样的代码有不可以保证变量的私有化，只是我们在变量之前添加下划线<code>_</code>（很多公司内部规定，或者已经成为了很多程序员的编程习惯，_开头的变量是私有的），这样每次实例化<code>Foo();</code>会只建立一个通用的<code>bar</code>方法。</p>
<h2>总结</h2>
<p>本文也不是说不要大家在<strong>javascript</strong>中写嵌套函数，只是要适当，要注意这个知识点，在频繁调用的函数内部是不推荐写javascript嵌套函数的。开发者写代码给用户用，为的就是高效代码提高用户体验。</p>
<p>英文全文：<a href="http://net.tutsplus.com/tutorials/javascript-ajax/stop-nesting-functions-but-not-all-of-them" target="_blank">http://net.tutsplus.com/tutorials/javascript-ajax/stop-nesting-functions-but-not-all-of-them</a></p>

      
    </div>
    <footer>
      
        


<div class="articletags clearfix">
	<i class="icon-tag"></i>Tags: <a href="/tags/性能/">性能</a>
	<i class="icon-folder"></i>categories:  <a href="/categories/前端开发/">前端开发</a>
</div>


        
<div id="bdshare" class="bdshare_t bds_tools get-codes-bdshare">
<span class="bds_more">分享到：</span>
<a class="bds_tsina">新浪微博</a>
<a class="bds_qzone">QQ空间</a>
<a class="bds_tqq">腾讯微博</a>
<a class="bds_renren">人人网</a>
<a class="bds_douban">豆瓣网</a>
<a class="bds_bdhome">百度首页</a>
<a class="bds_youdao">有道云笔记</a>
<a class="bds_copy">复制网址</a>
</div>
<script>
var bds_config = {
    wbUid:'2037334587',
    tsina: '61439547',
    pic:''
};
</script>



        <div class="pagepart clearfix">
 
	<a href="/2011/10/21/chrome扩展应用开发教程之开发chrome应用基础/" class="prev" title="chrome扩展应用开发教程之开发chrome应用基础">chrome扩展应用开发教程之开发chrome应用基础</a>
 
 
	<a href="/2011/10/18/html5的sessionstorage和localstorage/" class="next" title="HTMl5的sessionStorage和localStorage">HTMl5的sessionStorage和localStorage</a>
 
</div>
      
      
<div class="border"></div>
<section class="comment">
    <p class="title ico-comment">文章评论<a name="comments"></a></p>
    <div class="ds-thread" data-title="javascript嵌套函数的效率问题"></div>
</section>


      <div class="clearfix"></div>
    </footer>
  </div>
</article>


</div></div>
    <aside id="sidebar" class="alignright">
  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/乱七八糟/">乱七八糟</a><small>30</small></li>
  
    <li><a href="/categories/前端开发/">前端开发</a><small>116</small></li>
  
    <li><a href="/categories/后端运维/">后端运维</a><small>27</small></li>
  
    <li><a href="/categories/王婆卖瓜/">王婆卖瓜</a><small>4</small></li>
  
    <li><a href="/categories/读书笔记/">读书笔记</a><small>5</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签</h3>
  <ul class="entry clearfix">
  
    <li><a href="/tags/DOM/">DOM<sup>2</sup></a></li>
  
    <li><a href="/tags/IE/">IE<sup>1</sup></a></li>
  
    <li><a href="/tags/IE6/">IE6<sup>2</sup></a></li>
  
    <li><a href="/tags/PPT/">PPT<sup>3</sup></a></li>
  
    <li><a href="/tags/VPS/">VPS<sup>1</sup></a></li>
  
    <li><a href="/tags/ajax/">ajax<sup>5</sup></a></li>
  
    <li><a href="/tags/apache/">apache<sup>1</sup></a></li>
  
    <li><a href="/tags/audio/">audio<sup>2</sup></a></li>
  
    <li><a href="/tags/a标签/">a标签<sup>1</sup></a></li>
  
    <li><a href="/tags/canvas/">canvas<sup>1</sup></a></li>
  
    <li><a href="/tags/chrome/">chrome<sup>3</sup></a></li>
  
    <li><a href="/tags/css/">css<sup>15</sup></a></li>
  
    <li><a href="/tags/eAccelerator/">eAccelerator<sup>1</sup></a></li>
  
    <li><a href="/tags/ecmascript/">ecmascript<sup>3</sup></a></li>
  
    <li><a href="/tags/escape/">escape<sup>1</sup></a></li>
  
    <li><a href="/tags/event/">event<sup>1</sup></a></li>
  
    <li><a href="/tags/express/">express<sup>1</sup></a></li>
  
    <li><a href="/tags/grunt/">grunt<sup>1</sup></a></li>
  
    <li><a href="/tags/handleEvent/">handleEvent<sup>1</sup></a></li>
  
    <li><a href="/tags/html5/">html5<sup>3</sup></a></li>
  
    <li><a href="/tags/iframe/">iframe<sup>1</sup></a></li>
  
    <li><a href="/tags/iptables/">iptables<sup>1</sup></a></li>
  
    <li><a href="/tags/javascript/">javascript<sup>79</sup></a></li>
  
    <li><a href="/tags/linux/">linux<sup>4</sup></a></li>
  
    <li><a href="/tags/livereload/">livereload<sup>1</sup></a></li>
  
    <li><a href="/tags/memcached/">memcached<sup>1</sup></a></li>
  
    <li><a href="/tags/mixjs/">mixjs<sup>1</sup></a></li>
  
    <li><a href="/tags/mysql/">mysql<sup>2</sup></a></li>
  
    <li><a href="/tags/name/">name<sup>1</sup></a></li>
  
    <li><a href="/tags/nginx/">nginx<sup>2</sup></a></li>
  
    <li><a href="/tags/nodejs/">nodejs<sup>7</sup></a></li>
  
    <li><a href="/tags/php/">php<sup>19</sup></a></li>
  
    <li><a href="/tags/session/">session<sup>1</sup></a></li>
  
    <li><a href="/tags/storage/">storage<sup>1</sup></a></li>
  
    <li><a href="/tags/svn/">svn<sup>1</sup></a></li>
  
    <li><a href="/tags/this/">this<sup>1</sup></a></li>
  
    <li><a href="/tags/ueditor/">ueditor<sup>1</sup></a></li>
  
    <li><a href="/tags/uglifyjs/">uglifyjs<sup>1</sup></a></li>
  
    <li><a href="/tags/webbench/">webbench<sup>1</sup></a></li>
  
    <li><a href="/tags/websocket/">websocket<sup>1</sup></a></li>
  
    <li><a href="/tags/web前端开发/">web前端开发<sup>5</sup></a></li>
  
    <li><a href="/tags/windows7技巧/">windows7技巧<sup>1</sup></a></li>
  
    <li><a href="/tags/wordpress/">wordpress<sup>3</sup></a></li>
  
    <li><a href="/tags/xss/">xss<sup>3</sup></a></li>
  
    <li><a href="/tags/严格模式/">严格模式<sup>1</sup></a></li>
  
    <li><a href="/tags/位运算/">位运算<sup>1</sup></a></li>
  
    <li><a href="/tags/作用域/">作用域<sup>3</sup></a></li>
  
    <li><a href="/tags/前端优化/">前端优化<sup>1</sup></a></li>
  
    <li><a href="/tags/前端工具/">前端工具<sup>4</sup></a></li>
  
    <li><a href="/tags/加速器/">加速器<sup>1</sup></a></li>
  
    <li><a href="/tags/压力测试/">压力测试<sup>1</sup></a></li>
  
    <li><a href="/tags/右键/">右键<sup>1</sup></a></li>
  
    <li><a href="/tags/安全/">安全<sup>1</sup></a></li>
  
    <li><a href="/tags/性能/">性能<sup>3</sup></a></li>
  
    <li><a href="/tags/我也八卦/">我也八卦<sup>1</sup></a></li>
  
    <li><a href="/tags/执行环境/">执行环境<sup>1</sup></a></li>
  
    <li><a href="/tags/技巧/">技巧<sup>1</sup></a></li>
  
    <li><a href="/tags/播放器/">播放器<sup>1</sup></a></li>
  
    <li><a href="/tags/数组/">数组<sup>1</sup></a></li>
  
    <li><a href="/tags/标签/">标签<sup>1</sup></a></li>
  
    <li><a href="/tags/模块化/">模块化<sup>2</sup></a></li>
  
    <li><a href="/tags/算法/">算法<sup>1</sup></a></li>
  
    <li><a href="/tags/网络技术/">网络技术<sup>73</sup></a></li>
  
    <li><a href="/tags/虚拟主机/">虚拟主机<sup>1</sup></a></li>
  
    <li><a href="/tags/解耦/">解耦<sup>1</sup></a></li>
  
    <li><a href="/tags/语法限制/">语法限制<sup>1</sup></a></li>
  
    <li><a href="/tags/跨域/">跨域<sup>3</sup></a></li>
  
    <li><a href="/tags/路径/">路径<sup>1</sup></a></li>
  
    <li><a href="/tags/软件心得/">软件心得<sup>3</sup></a></li>
  
  </ul>
</div>



  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2013 三水清
  
</div>
<div class="clearfix"></div></footer>
  <script src="http://libs.baidu.com/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


    
        <script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=6635976" ></script>
        <script type="text/javascript" id="bdshell_js"></script>
        <script type="text/javascript">
        document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000);
        </script>
    
    
    <script type="text/javascript">
        var duoshuoQuery = {short_name:"ksky521"};
        (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';ds.async = true;
            ds.src = 'http://static.duoshuo.com/embed.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0]
            || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
    </script>
    



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>




    <script type="text/javascript">
    var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F1c76f5cc8274a56106b13b9c9b1fb046' type='text/javascript'%3E%3C/script%3E"));
    </script>


</body>
</html>